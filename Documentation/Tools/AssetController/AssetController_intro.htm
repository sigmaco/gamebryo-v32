<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>Asset Controller: Introduction</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Expedition" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->

<!--(Begin Links)===================================================-->

<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2"
type="text/javascript">
</script><script language="JavaScript1.2" type="text/javascript">
WriteNavLink(2);
</script>

<h1>Asset Controller: Introduction</h1>

<p>The Asset Controller is a Windows application that provides
additional runtime asset services for games and tools. It is also
the application that generates the metadata files that are used
by the game runtime to identify assets. The Gamebryo tools
require an Asset Controller to resolve asset files that are
selected in the tool by the developer. For this reason, the
Toolbench application automatically starts the Asset Controller
if it is not already running.</p>

<p>The fundamental reason for using a shared Asset Controller
over a distributed connection is so that all processes involved
in the session, such as editors and on-target previewers, will
see a consistent set of assets, even as they are being modified
in real time.</p>

<p>A game can run without connecting to an Asset Controller. If
there is no Asset Controller, then all asset IDs are resolved
locally by the Asset Locator. However, if the game is connected
to an Asset Controller, then all lookups are forwarded to it, and
the Asset Controller is able to provide results based on the
current state of the assets stored in the Asset Web Root. So assets
may be added, removed, or modified, and these changes are
available immediately within the context of the running game. It
is this connectivity that is used to support rapid iteration
workflows.</p>

<p>In summary, the Asset Controller has three main purposes:</p>

<ul>
    <li>Create and update the metadata that is needed for
    locating assets. This is normally done by invoking the Asset
    Controller in a build step for the project.</li>

    <li>Serve asset lookup requests that the Toolbench initiates.
    Toolbench will ensure that there is always an Asset
    Controller running for this purpose.</li>

    <li>Monitor assets during rapid iteration workflows, making
    up-to-the-moment changes available to a running game.</li>
</ul>

<p class="NDLHeadingRelatedTopic">Related topics</p>

<ul>
    <li><a href=
    "../../Programmer/AssetRuntimeService/asset_runtime_intro.htm">
    Asset Runtime Service: Introduction</a></li>

    <li><a href=
    "../../Programmer/AssetRuntimeService/asset_runtime_cli_ref.htm">
    Asset Runtime Service command line reference</a></li>

    <li><a href=
    "../../Programmer/AssetRuntimeService/asset_runtime_deploying_assets.htm">Deploying
    assets</a></li>

    <li><a href=
    "../../Programmer/AssetRuntimeService/asset_runtime_best_practice.htm">
    Best practices for working with the Asset Runtime
    Service</a></li>
</ul>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

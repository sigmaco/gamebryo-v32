<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>efd::Archive</title>
<!--(Begin Meta)================================================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Expedition" />
<meta name="Generator" content="DoxyConvert by Emergent Game Technologies - http://emergent.net" />

<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)==================================================================================-->
    
<!--(Begin Links)===============================================================================-->

<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=================================================================================-->

</head>
  
<!--(Body)======================================================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<p class="NDLRefHeadClassTitle">efd::Archive</p>


<p class="NDLRefHeaderFile">&lt;Archive.h&gt;</p>


<p class="NDLRefHead1">Description</p>
<p class="NDLNormal">An <span class="NDLSystemFont">Archive</span> provides the storage media for data marshaling. </p>
<p class="NDLNormal">You can toss objects into the archive using Serialize and then later use the exact same code to retrieve the objects. Archives help protect against data overflows and underflows too.</p>
<p class="NDLNormal">Sample usage for packing: 
<pre>        Archive ar(Archive::Packing);
        Serializer::SerializeObject(object1, ar);
        ...
        Serializer::SerializeObject(objectN, ar);
        if (!ar.GetError())
        {
            SmartBuffer sbResult = ar.GetUsedBuffer();
            // sbResult now contains the marshaled data, it could be written to the wire or
            // persisted to disk or whatever.
        }
</pre>
</p>
<p class="NDLNormal">Sample usage for unpacking: 
<pre>        Archive ar(Archive::Unpacking, pData, cbData);
        Serializer::SerializeObject(object1, ar);
        ...
        Serializer::SerializeObject(objectN, ar);
        ar.CheckForUnderflow();
        if (!ar.GetError())
        {
            // use the unpacked results
        }
</pre>
</p>

<a name="public_types"></a>
<p class="NDLRefHead1">Public Types</p>
<a name="classefd_1_1_archive_1a29044df221479aa198fabb51b8d98a44"></a>
<p class=NDLRefHead2>efd::Archive::_Packing</p>




<!--(Table)=========================================================-->
<div class="ReferenceTable">
<table>
  <thead>
	<tr>
        <th>Name</th>
	    <th>Description</th>
    </tr>
  </thead>
  <tbody>  
<tr>
    <td><span class="NDLSystemFont">Packing</span></td>
    <td>&nbsp;</td>
</tr>

  </tbody>
</table>
</div>

<a name="classefd_1_1_archive_1a68da4644b9159eafd8400833f1d6ba8f"></a>
<p class=NDLRefHead2>efd::Archive::_Unpacking</p>




<!--(Table)=========================================================-->
<div class="ReferenceTable">
<table>
  <thead>
	<tr>
        <th>Name</th>
	    <th>Description</th>
    </tr>
  </thead>
  <tbody>  
<tr>
    <td><span class="NDLSystemFont">Unpacking</span></td>
    <td>&nbsp;</td>
</tr>

  </tbody>
</table>
</div>


<a name="public_methods"></a>
<p class="NDLRefHead1">Public Methods</p>


<a name="classefd_1_1_archive_1a0acc4a7de276dd2c55a878a81a3dc66a"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span>  GetUsedBuffer()</p>
<p class="NDLRefMemberDescription">Create a <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span> representing the currently used portion of the archive. </p>

<a name="classefd_1_1_archive_1a6c8e8aabcb2fdf6c1669799bd44f5782"></a>
<p class="NDLRefMemberFunction">const <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span>  GetUsedBuffer() const</p>
<p class="NDLRefMemberDescription">Create a <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span> representing the currently used portion of the archive. </p>

<a name="classefd_1_1_archive_1a91be5e88369530373641d13ed214069a"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span>  GetRemainingBuffer()</p>
<p class="NDLRefMemberDescription">Create a <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span> representing the currently unused portion of the archive. </p>

<a name="classefd_1_1_archive_1af3212951b4340034df7ff4356a6239bb"></a>
<p class="NDLRefMemberFunction">const <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span>  GetRemainingBuffer() const</p>
<p class="NDLRefMemberDescription">Create a <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span> representing the currently used portion of the archive. </p>

<a name="classefd_1_1_archive_1a4fd26d3c89ef93ee56d33bdc305ee964"></a>
<p class="NDLRefMemberFunction">const <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span>&  GetEntireBuffer() const</p>
<p class="NDLRefMemberDescription">Create a <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span> representing the entire buffer used by the archive. </p>
<p class="NDLRefMemberDetailedDescription">This is a seldom needed method, typically only the used portion of the archive is of interest so you should consider using GetUsedBuffer instead. </p>

<a name="classefd_1_1_archive_1a6cf7d81810fe4f96115ee1e0b74d549f"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a2309799229c6568d5d3b8d1921d74122">efd::Endianness</a></span>  GetEndianness() const</p>
<p class="NDLRefMemberDescription">Gets the endianness of the archive. The endianness will default to the hardware endianness. </p>

<a name="classefd_1_1_archive_1ae619ee84cb8d521942c6f30f7afd0683"></a>
<p class="NDLRefMemberFunction">void  SetEndianness(<span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a2309799229c6568d5d3b8d1921d74122">efd::Endianness</a></span> val)</p>
<p class="NDLRefMemberDescription">Sets the endianness of the archive. </p>
<p class="NDLRefMemberDetailedDescription">Set this on packing or unpacking archives after the are constructed but before they are first used to serialize data. This method will assert if the endianness is changed after the archive had been used for serialization. </p>

<a name="classefd_1_1_archive_1aaa40516c10e920b26fde6a330bef5837"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  NeedsSwap()</p>
<p class="NDLRefMemberDescription">Returns true if the archive's endianness differs from the hardware's endianness. </p>

<a name="classefd_1_1_archive_1aeb84c904313c2246b6e59c4ad2423e3f"></a>
<p class="NDLRefMemberFunction">template &lt;typename T  &gt; void  MaybeSwap(<br/>const T& i_value, <br/>T& o_result)</p>
<p class="NDLRefMemberDescription">Assigns the given value to the resulting value with a possible byte swap to adjust the endianness if necessary. </p>
<p class="NDLRefMemberDetailedDescription">This only works for plain-old-data types (integers, floats, enums). </p>

<a name="classefd_1_1_archive_1a5e30fc5c4934aed2cfaea7139144fe20"></a>
<p class="NDLRefMemberFunction">static <span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a2309799229c6568d5d3b8d1921d74122">efd::Endianness</a></span>  GetHardwareEndianness()</p>
<p class="NDLRefMemberDescription">Gets the endianness of the hardware. </p>
<p class="NDLRefMemberDetailedDescription">Intel architectures are typically little endian and everything else is typically big endian. </p>

<a name="classefd_1_1_archive_1a6f9f3615ddbb65aa5fa7426e6ffb63c4"></a>
<p class="NDLRefMemberFunction">Archive()</p>
<p class="NDLRefMemberDescription">Default Constructor. Creates an archive for packing. </p>

<a name="classefd_1_1_archive_1a49e8f0a3de1ebf2f4f467ce1ddec8819"></a>
<p class="NDLRefMemberFunction">Archive(<span class="NDLSystemFont"><a href="efd__Archive.htm#classefd_1_1_archive_1a29044df221479aa198fabb51b8d98a44">_Packing</a></span> )</p>
<p class="NDLRefMemberDescription">Constructor. Explicit version of the default constructor to provide consistent syntax. </p>

<a name="classefd_1_1_archive_1a246005e33129999eba77b674e1f53b10"></a>
<p class="NDLRefMemberFunction">Archive(<br/><span class="NDLSystemFont"><a href="efd__Archive.htm#classefd_1_1_archive_1a29044df221479aa198fabb51b8d98a44">_Packing</a></span> , <br/>void* i_pBuffer, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbBuffer)</p>
<p class="NDLRefMemberDescription">Constructor. </p>
<p class="NDLRefMemberDetailedDescription">Pack into a borrowed buffer. The caller must ensure the lifetime of the provided buffer exceeds the lifetime of the <span class="NDLSystemFont">Archive</span>. If you want the <span class="NDLSystemFont">Archive</span> to adopt the buffer instead, use: 
<pre>     Archive(Archive::Packing, SmartBuffer(Adopt, i_pBuffer, i_cbBuffer));
</pre>
</p>

<a name="classefd_1_1_archive_1af679003629c979ad4e81b27823a18cd8"></a>
<p class="NDLRefMemberFunction">Archive(<br/><span class="NDLSystemFont"><a href="efd__Archive.htm#classefd_1_1_archive_1a29044df221479aa198fabb51b8d98a44">_Packing</a></span> , <br/>const <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span>& i_buffer)</p>
<p class="NDLRefMemberDescription">Constructor. Pack into the provided <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span>. </p>

<a name="classefd_1_1_archive_1a9f494c08415d1d0255576ede500dd613"></a>
<p class="NDLRefMemberFunction">Archive(<br/><span class="NDLSystemFont"><a href="efd__Archive.htm#classefd_1_1_archive_1a68da4644b9159eafd8400833f1d6ba8f">_Unpacking</a></span> , <br/>const void* i_pBuffer, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbBuffer)</p>
<p class="NDLRefMemberDescription">Constructor. </p>
<p class="NDLRefMemberDetailedDescription">Unpack from a borrowed buffer. The caller must ensure the lifetime of the provided buffer exceeds the lifetime of the <span class="NDLSystemFont">Archive</span>. The memory in the buffer will be read but will not be modified by the archive. If you want the <span class="NDLSystemFont">Archive</span> to adopt the buffer instead, use: 
<pre>     Archive(Archive::Unpacking, SmartBuffer(Adopt, i_pBuffer, i_cbBuffer));
</pre>
</p>

<a name="classefd_1_1_archive_1aee15fd72a1be0ca9e86b6ed67fb657ed"></a>
<p class="NDLRefMemberFunction">Archive(<br/><span class="NDLSystemFont"><a href="efd__Archive.htm#classefd_1_1_archive_1a68da4644b9159eafd8400833f1d6ba8f">_Unpacking</a></span> , <br/>const <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span>& i_buffer)</p>
<p class="NDLRefMemberDescription">Constructor. Unpack from the provided <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span>. </p>

<a name="classefd_1_1_archive_1ac1dd1677e8ba8604ec512ac6bc7330e5"></a>
<p class="NDLRefMemberFunction">~Archive()</p>
<p class="NDLRefMemberDescription">Destructor. </p>

<a name="classefd_1_1_archive_1aed99e7086df9ac7ec4f8206385451c9f"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  IsPacking() const</p>
<p class="NDLRefMemberDescription">Determine if this archive is being used for packing. </p>

<a name="classefd_1_1_archive_1a86f11bbe861b5fea40e89a70fb34a601"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  IsUnpacking() const</p>
<p class="NDLRefMemberDescription">Determine if this archive is being used for unpacking. </p>

<a name="classefd_1_1_archive_1a0c1c6b383a3dea709ca2930e3bbda5de"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  GetError() const</p>
<p class="NDLRefMemberDescription">Determine if any errors have been raised on this archive. </p>

<a name="classefd_1_1_archive_1abbe777ff020cffcfa4190c78b48d1e15"></a>
<p class="NDLRefMemberFunction">void  RaiseError()</p>
<p class="NDLRefMemberDescription">Raise an error on the current archive. This will assert when called. </p>

<a name="classefd_1_1_archive_1a6848123240d3f4e8b2fae4f04b42fd2c"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span>  GetCurrentPosition() const</p>
<p class="NDLRefMemberDescription">Determine the current position in the archive. </p>

<a name="classefd_1_1_archive_1acfe8367fb512828db726f7cc7b80fc00"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span>  GetUsedSize() const</p>
<p class="NDLRefMemberDescription">Determine how many bytes of the archive have been used. </p>

<a name="classefd_1_1_archive_1a8fac34862a59e0204a423bd6d699f6ce"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span>  GetRemainingSize() const</p>
<p class="NDLRefMemberDescription">Determine the bytes remaining in the archive. </p>
<p class="NDLRefMemberDetailedDescription">When unpacking this number is the limit of how much can be read from the archive, but when packing this amount can change if the underlying <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">SmartBuffer</a></span> grows. </p>

<a name="classefd_1_1_archive_1a02f702f1d202f7f4e001eb5782a98110"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  CheckBytes(<span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbSize)</p>
<p class="NDLRefMemberDescription">Returns true if the given number of bytes remain in the archive. </p>
<p class="NDLRefMemberDetailedDescription">Will grow the archive if necessary and possible. Will RaiseError if there isn't enough room left. This can also help with efficiency when packing a large amount of data of know size. By calling a single CheckBytes up front you will grow the buffer just once and avoid the cost of multiple smaller grows which might otherwise occur as you pack the sub components. </p>

<a name="classefd_1_1_archive_1ace903b1d4c4760f4145c6e908302159b"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a59a3838ab5cdfe87f98f5b8371e4e91d">efd::UInt8</a></span>*  GetBytes(<span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbSize)</p>
<p class="NDLRefMemberDescription">GetBytes is used to access a block of the buffer. </p>
<p class="NDLRefMemberDetailedDescription">It will grow the buffer if needed (and that is possible). If there isn't enough room it will RaiseError and return NULL. It it not typically safe to cache the resulting pointer since it will become invalid if the archive grows and will most often become invalid when the archive is destroyed (there are rare exceptions when unpacking from a borrowed buffer). </p>

<a name="classefd_1_1_archive_1ac3eb97c1efd7f689e13956fe553502d1"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a59a3838ab5cdfe87f98f5b8371e4e91d">efd::UInt8</a></span>*  PeekBytes(<br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbOffset, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbSize)</p>
<p class="NDLRefMemberDescription">Grabs a pointer directly into the archive without adjusting the current location. </p>
<p class="NDLRefMemberDetailedDescription">Will grow the buffer if necessary and possible. If there isn't enough room it will RaiseError and return NULL. Caching the resulting pointer isn't recommended, see GetBytes for details. You can pass in a previous position obtained by calling <span class="NDLSystemFont"><a href="efd__Archive.htm#classefd_1_1_archive_1a6848123240d3f4e8b2fae4f04b42fd2c">GetCurrentPosition()</a></span> in order to update previous positions in the archive. An example might be if you were packing a linked <span class="NDLSystemFont"><a href="efd__list.htm">list</a></span> of unknown size. You might call <span class="NDLSystemFont"><a href="efd__Archive.htm#classefd_1_1_archive_1a6848123240d3f4e8b2fae4f04b42fd2c">GetCurrentPosition()</a></span> and then pack a dummy size of zero into the archive. Then you could walk the <span class="NDLSystemFont"><a href="efd__list.htm">list</a></span> packing each element and counting the number of elements. When you are done you could use the stored position to PeekBytes and write the actual number of elements packed. Although this is possible its not typically recommended as it forces your "packing" and "unpacking" code paths to diverge. </p>

<a name="classefd_1_1_archive_1aa56b6aeffc313998efba74c0961c6674"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">Archive</span>  MakeWindow(<span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbSize)</p>
<p class="NDLRefMemberDescription">Make another archive representing a window into the current archive's buffer at the current position in this archive. </p>
<p class="NDLRefMemberDetailedDescription">This will advance the archive by the requested size if needed. The new archive will have the same pack/unpack mode as the current archive. This can be used to reserve a chunk of space in the archive which can be packed or unpacked at a later time. For example, when packing you might make a 4 byte window before walking a linked <span class="NDLSystemFont"><a href="efd__list.htm">list</a></span> and then count the number of elements actually serialized. When finished you can serialize the actual number of elements into the reserved window. </p>

<a name="classefd_1_1_archive_1a81836da9f79df95b2a821d593ee81044"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  CheckForUnderflow()</p>
<p class="NDLRefMemberDescription">You can call this after you finish unpacking from a buffer. </p>
<p class="NDLRefMemberDetailedDescription">It will raise an error if the entire buffer wasn't consumed </p>
 
<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

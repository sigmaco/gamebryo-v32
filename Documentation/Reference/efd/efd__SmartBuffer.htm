<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>efd::SmartBuffer</title>
<!--(Begin Meta)================================================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Expedition" />
<meta name="Generator" content="DoxyConvert by Emergent Game Technologies - http://emergent.net" />

<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)==================================================================================-->
    
<!--(Begin Links)===============================================================================-->

<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=================================================================================-->

</head>
  
<!--(Body)======================================================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<p class="NDLRefHeadClassTitle">efd::SmartBuffer</p>


<p class="NDLRefHeaderFile">&lt;SmartBuffer.h&gt;</p>


<p class="NDLRefHead1">Description</p>
<p class="NDLNormal">A <span class="NDLSystemFont">SmartBuffer</span> is a sized window into a <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span>. </p>
<p class="NDLNormal">They can be quickly and cheaply copied since they share a reference to the actual memory through the <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span>. The internal <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span> is automatically maintained so you can effectively think of <span class="NDLSystemFont">SmartBuffer</span> as being a generic resizable memory buffer that can be cheaply "copied" around. The practical result of this is that <span class="NDLSystemFont">SmartBuffer</span> instances are typically placed on the <span class="NDLSystemFont"><a href="efd__stack.htm">stack</a></span> rather than being allocated from the heap. </p>

<a name="public_methods"></a>
<p class="NDLRefHead1">Public Methods</p>


<a name="classefd_1_1_smart_buffer_1ae6b8686910519f7ce4bd4f5ace1401ef"></a>
<p class="NDLRefMemberFunction">SmartBuffer()</p>
<p class="NDLRefMemberDescription">Default Constructor. Uses a growable, owned, initially NULL <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span>. </p>

<a name="classefd_1_1_smart_buffer_1a8dbb6b5c055130560799e9a2e57c81d4"></a>
<p class="NDLRefMemberFunction">SmartBuffer(<span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbInitialSize)</p>
<p class="NDLRefMemberDescription">Constructor. Uses a growable, owned <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span> of the given initial size. </p>

<a name="classefd_1_1_smart_buffer_1a7ceaa6fe1fe800ef8c0a5f06bc92eabf"></a>
<p class="NDLRefMemberFunction">SmartBuffer(<br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1abd1722e6416223f55fb106ab3c6cf2fa">_Borrow</a></span> , <br/>void* i_pData, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbData)</p>
<p class="NDLRefMemberDescription">Borrow Constructor. </p>
<p class="NDLRefMemberDetailedDescription">Creates a <span class="NDLSystemFont">SmartBuffer</span> using a <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span> that will borrow the provided memory. </p>

<a name="classefd_1_1_smart_buffer_1ab10cef9946ed8945f48eb99738be0f69"></a>
<p class="NDLRefMemberFunction">SmartBuffer(<br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a805d2ba8fe04738f2b7417afc3da9513">_Adopt</a></span> , <br/>void* i_pData, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbData)</p>
<p class="NDLRefMemberDescription">Adopt Constructor. </p>
<p class="NDLRefMemberDetailedDescription">Creates a <span class="NDLSystemFont">SmartBuffer</span> using a <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span> that will adopt the provided memory. </p>

<a name="classefd_1_1_smart_buffer_1ae6395a3eb492624202c62823ff075913"></a>
<p class="NDLRefMemberFunction">SmartBuffer(<span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span>* sourceBuffer)</p>
<p class="NDLRefMemberDescription">Constructor. </p>
<p class="NDLRefMemberDetailedDescription">Creates a <span class="NDLSystemFont">SmartBuffer</span> with a reference to a specific pre-existing <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span> instance. A reference will be held to this buffer. The entire buffer will be used by the resulting <span class="NDLSystemFont">SmartBuffer</span>, to restrict this call MakeWindow on the result. </p>

<a name="classefd_1_1_smart_buffer_1ae38184c7573de6f2597feb01516877f6"></a>
<p class="NDLRefMemberFunction">SmartBuffer(const <span class="NDLSystemFont">SmartBuffer</span>& i_rhs)</p>
<p class="NDLRefMemberDescription">Copy Constructor. </p>

<a name="classefd_1_1_smart_buffer_1ac4cbe7cd1b2b40c635439ccd88361fa8"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">SmartBuffer</span>&  operator=(const <span class="NDLSystemFont">SmartBuffer</span>& i_rhs)</p>
<p class="NDLRefMemberDescription">Assignment Operator. </p>

<a name="classefd_1_1_smart_buffer_1ab168385d224b058cd97f42b4b1b89930"></a>
<p class="NDLRefMemberFunction">~SmartBuffer()</p>
<p class="NDLRefMemberDescription">Destructor. </p>

<a name="classefd_1_1_smart_buffer_1a40375fd4c2f4c5b62871d86c6758d5b2"></a>
<p class="NDLRefMemberFunction">void  Adopt(<br/>void* i_pData, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbData)</p>
<p class="NDLRefMemberDescription">Any previously owned buffer is released and the provided memory is adopted by a new <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span>. </p>
<p class="NDLRefMemberDetailedDescription">The memory will be freed using EE_EXTERNAL_DELETE when the <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span> is destroyed. </p>

<a name="classefd_1_1_smart_buffer_1a7c604b3aa9ab2a5e77fc0baa65e43642"></a>
<p class="NDLRefMemberFunction">void  Borrow(<br/>void* i_pData, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbData)</p>
<p class="NDLRefMemberDescription">Any previously owned buffer is released and the provided memory is borrowed by a new <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span>. </p>
<p class="NDLRefMemberDetailedDescription">The caller must maintain the lifetime of the memory used and must ensure the memory remains available for the life of the <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span>, which means for the lifetime of this <span class="NDLSystemFont">SmartBuffer</span> and any copy or window made into this <span class="NDLSystemFont">SmartBuffer</span>. Borrowed buffers cannot be grown, only the borrowed memory will be used. </p>

<a name="classefd_1_1_smart_buffer_1a5a76e5a58ede8f2f0fa83c4dc219b187"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a59a3838ab5cdfe87f98f5b8371e4e91d">efd::UInt8</a></span>*  Orphan()</p>
<p class="NDLRefMemberDescription">Orphan any memory we own. </p>
<p class="NDLRefMemberDetailedDescription">The caller is responsible for deleting the memory using EE_EXTERNAL_DELETE. Once the memory has been deleted then the <span class="NDLSystemFont">SmartBuffer</span> will no longer be valid, but the buffer continues to point to the orphaned memory. </p>

<a name="classefd_1_1_smart_buffer_1adb0941a5e193791a0cb89b692d4d5fca"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  Grow(<span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbNewSize)</p>
<p class="NDLRefMemberDescription">Grow to a good size not smaller than i_cbNewSize. </p>
<p class="NDLRefMemberDetailedDescription">Returns false if unable to grow, for example if you try to grow a borrowed buffer it would fail. </p>

<a name="classefd_1_1_smart_buffer_1a835d3d8c8f9d454cc70272f603e33a72"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  GrowExclusive(<span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_cbNewSize)</p>
<p class="NDLRefMemberDescription">Grow to a good size not smaller than i_cbNewSize. </p>
<p class="NDLRefMemberDetailedDescription">Returns false if unable to grow, for example if you try to grow a borrowed buffer it would fail. This will also allocate a new buffer if more than one reference is held to the original buffer. </p>

<a name="classefd_1_1_smart_buffer_1ac83b78327eb09bc99f8ad6475bd757a9"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">SmartBuffer</span>  Clone()</p>
<p class="NDLRefMemberDescription">Make a copy of the buffer. </p>
<p class="NDLRefMemberDetailedDescription">This creates a new <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span> owned by the new <span class="NDLSystemFont">SmartBuffer</span> and copies the used memory into the buffer. </p>

<a name="classefd_1_1_smart_buffer_1aa2d598257489d6667bc0b5282227ec89"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">SmartBuffer</span>  MakeWindow(<br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_start, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_size = -1)</p>
<p class="NDLRefMemberDescription">Create a <span class="NDLSystemFont">SmartBuffer</span> that represents a window into the current buffer. </p>
<p class="NDLRefMemberDetailedDescription">The new <span class="NDLSystemFont">SmartBuffer</span> will share a reference to the original memory buffer.</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">i_start</span></td>
    <td>The starting offset for the new window. </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">i_size</span></td>
    <td>The size for the new window, or -1 to make a window to the end of the buffer. </td>
</tr>
<tr>
    <td><em>Return Value</em></td>
    <td>A new <span class="NDLSystemFont">SmartBuffer</span> representing a window into the current <span class="NDLSystemFont">SmartBuffer</span></td>
</tr>

        </tbody>
    </table>
</div>



<a name="classefd_1_1_smart_buffer_1aee61148455e781920705555de79daf0b"></a>
<p class="NDLRefMemberFunction">const <span class="NDLSystemFont">SmartBuffer</span>  MakeWindow(<br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_start, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_size = -1) const</p>
<p class="NDLRefMemberDescription">Create a <span class="NDLSystemFont">SmartBuffer</span> that represents a window into the current buffer, const version. </p>
<p class="NDLRefMemberDetailedDescription">The new <span class="NDLSystemFont">SmartBuffer</span> will share a reference to the original memory buffer.</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">i_start</span></td>
    <td>The starting offset for the new window. </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">i_size</span></td>
    <td>The size for the new window, or -1 to make a window to the end of the buffer. </td>
</tr>
<tr>
    <td><em>Return Value</em></td>
    <td>A new const <span class="NDLSystemFont">SmartBuffer</span> representing a window into the current <span class="NDLSystemFont">SmartBuffer</span></td>
</tr>

        </tbody>
    </table>
</div>



<a name="classefd_1_1_smart_buffer_1ad2fb09bf396276268beed711978d531f"></a>
<p class="NDLRefMemberFunction">void  Shrink()</p>
<p class="NDLRefMemberDescription">Shrinks the buffer to the minimum size. </p>
<p class="NDLRefMemberDetailedDescription">This can actually increase memory usage since the original master buffer might have other references to it. If the buffer is being shared both the new and old buffers will remain. </p>

<a name="classefd_1_1_smart_buffer_1ab55ac46413eaf5d3a8635d0dcf0efede"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a59a3838ab5cdfe87f98f5b8371e4e91d">efd::UInt8</a></span>*  GetBuffer()</p>
<p class="NDLRefMemberDescription">Get a temporary pointer to the current internal buffer. </p>
<p class="NDLRefMemberDetailedDescription">Do not cache pointers returned by GetBuffer, they will become invalid if the <span class="NDLSystemFont">SmartBuffer</span> grows. Instead, consider storing an offset into the buffer. </p>

<a name="classefd_1_1_smart_buffer_1adefe713ccd4c6b8d7a1c760fb12044b3"></a>
<p class="NDLRefMemberFunction">const <span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a59a3838ab5cdfe87f98f5b8371e4e91d">efd::UInt8</a></span>*  GetBuffer() const</p>
<p class="NDLRefMemberDescription">Get a temporary pointer to the current internal buffer, const version. </p>
<p class="NDLRefMemberDetailedDescription">Do not cache pointers returned by GetBuffer, they will become invalid if the <span class="NDLSystemFont">SmartBuffer</span> grows. Instead, consider storing an offset into the buffer. </p>

<a name="classefd_1_1_smart_buffer_1accef41f25936daf6b8a17db3abfe0f95"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span>  GetSize() const</p>
<p class="NDLRefMemberDescription">Get the size of the <span class="NDLSystemFont">SmartBuffer</span>. </p>

<a name="classefd_1_1_smart_buffer_1afdf92011602448eabdb8466569246289"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  CanGrow() const</p>
<p class="NDLRefMemberDescription">Check if the current buffer is able to grow. </p>
<p class="NDLRefMemberDetailedDescription">Owned buffers can be grown but borrowed buffers cannot. </p>

<a name="classefd_1_1_smart_buffer_1a3c39521a31f2ca4c4004debb9698c1d3"></a>
<p class="NDLRefMemberFunction">void  Serialize(<span class="NDLSystemFont"><a href="efd__Archive.htm">Archive</a></span>& io_ar)</p>
<p class="NDLRefMemberDescription">Serialize a smart buffer into an archive. </p>
<p class="NDLRefMemberDetailedDescription">The smart buffer is assumed to have compatible endianness with the archive and is serialized as size-prefixed raw bytes. </p>

<a name="classefd_1_1_smart_buffer_1a1ed4efc025bc29753bd6b8fa8abd2f54"></a>
<p class="NDLRefMemberFunction">void  ReleaseMasterBuffer()</p>
<p class="NDLRefMemberDescription">Release the <span class="NDLSystemFont"><a href="efd__GrowableBuffer.htm">GrowableBuffer</a></span> used by this <span class="NDLSystemFont">SmartBuffer</span>. </p>
<p class="NDLRefMemberDetailedDescription">This effectively resets the <span class="NDLSystemFont">SmartBuffer</span> to the initial empty state as if it had just been default constructed. </p>

<a name="classefd_1_1_smart_buffer_1abe4f128ac0920ab7eadf46ed1554c1d3"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  ReadFromFile(const <span class="NDLSystemFont"><a href="efd__utf8string.htm">efd::utf8string</a></span>& fileName)</p>
<p class="NDLRefMemberDescription">Fills the buffer with the contents of the given file. </p>

<a name="classefd_1_1_smart_buffer_1a08d9c0245a0dca41c5236d5190d755ce"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  WriteToFile(const <span class="NDLSystemFont"><a href="efd__utf8string.htm">efd::utf8string</a></span>& fileName) const</p>
<p class="NDLRefMemberDescription">Writes out entire contents of a buffer to a named file. </p>

<a name="classefd_1_1_smart_buffer_1a872dd0a2449350f2e3a171a1ee8014d4"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  IsEqual(const <span class="NDLSystemFont">SmartBuffer</span>& other)</p>
<p class="NDLRefMemberDescription">Compare the contents of two SmartBuffers to see if they are identical. </p>
 
<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>efd::ServiceDiscoveryRequest</title>
<!--(Begin Meta)================================================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Expedition" />
<meta name="Generator" content="DoxyConvert by Emergent Game Technologies - http://emergent.net" />

<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)==================================================================================-->
    
<!--(Begin Links)===============================================================================-->

<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=================================================================================-->

</head>
  
<!--(Body)======================================================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<p class="NDLRefHeadClassTitle">efd::ServiceDiscoveryRequest</p>
<p class="NDLRefParentage">: public <span class="NDLSystemFont"><a href="efd__IMessage.htm">efd::IMessage</a></span></p>


<p class="NDLRefHeaderFile">&lt;ServiceDiscoveryMessage.h&gt;</p>

<p class="NDLRefHead1" style="text-align: center; ">
<div class="FigureContainer">
  <img src="./images/classefd_1_1_service_discovery_request.gif" alt="Inheritance graph for efd::ServiceDiscoveryRequest"/>
  <p class="FigureCaption">Inheritance graph for efd::ServiceDiscoveryRequest</p>
</div>
</p>

<p class="NDLRefHead1">Description</p>
<p class="NDLNormal">A message to request discovery from all receiving system services. </p>
<p class="NDLNormal">Send this message to a category that the service is know to subscribe to (for example, a global well known channel) and all receiving services that implement service discovery will respond with their ClassID and a private channel for communication to that service instance. </p>

<a name="public_methods"></a>
<p class="NDLRefHead1">Public Methods</p>


<a name="classefd_1_1_service_discovery_request_1a0e78d325fb5d2c6a1c53d203c840344a"></a>
<p class="NDLRefMemberFunction">ServiceDiscoveryRequest()</p>
<p class="NDLRefMemberDetailedDescription">Default constructor. </p>

<a name="classefd_1_1_service_discovery_request_1ade7693b6f5a47117bffc5c25ea5e010a"></a>
<p class="NDLRefMemberFunction">ServiceDiscoveryRequest(<br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> i_userData, <br/><span class="NDLSystemFont"><a href="efd__Category.htm">efd::Category</a></span> i_callback)</p>
<p class="NDLRefMemberDescription">Create a service discovery request. </p>
<p class="NDLRefMemberDetailedDescription">Send this to a category that one or more services are expected to be listening on and everyone who receives the message will reply with their service ClassID and a private channel that can be used to communicate with that particular instance of the service.</p>
<p class="NDLRefMemberDetailedDescription">
<p class="NDLRefMemberDetailedDescription">: There is no way to tell if no services of that type exist since our message system can't tell you if message delivery fails due to no target subscribers. The best you can do is to wait for a while and assume that if no one has replied then no services of that type exist.</p></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">i_userData</span></td>
    <td>Arbitrary data that will be returned in all response messages. </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">i_callback</span></td>
    <td>The category to which responses should be sent. This should normally be a private category that the sender is already subscribed to. </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classefd_1_1_service_discovery_request_1a6cac8dd5a2973be68dbd8c46b048b0bb"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span>  GetContext() const</p>
<p class="NDLRefMemberDescription">Get the sender provided context value. </p>

<a name="classefd_1_1_service_discovery_request_1a71596a721896e3efa98c69c12cf5da4a"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="efd__Category.htm">efd::Category</a></span>  GetCallbackChannel() const</p>
<p class="NDLRefMemberDescription">Get the sender specified response category to which any response messages will be sent. </p>

<a name="classefd_1_1_service_discovery_request_1ae50316c052864b79529efe30f3da2215"></a>
<p class="NDLRefMemberFunction">virtual void  Serialize(<span class="NDLSystemFont"><a href="efd__Archive.htm">efd::Archive</a></span>& io_ar)</p>
<p class="NDLRefMemberDescription">Serialize a polymorphic type to or from an <span class="NDLSystemFont"><a href="efd__Archive.htm">Archive</a></span>. </p>
<p class="NDLRefMemberDetailedDescription">This method must be overridden, but if your streamable object has no data the override can be an empty function. A typical implementation of this method will make one call to <span class="NDLSystemFont"><a href="../Namespaces/efd__Serializer.htm#namespaceefd_1_1_serializer_1a63e0b99047011bde53be44786ab9ee7b">efd::Serializer::SerializeObject</a></span> for each member of the class. If you are derived from another streamable class you should be sure to call to parent implementation of this method as well; it is recommended that the parent class be serialized first before adding the data for the derived class. If your class contains complex data such as STL-style contianers or pointers to allocated data then you can simplify the implementation of Serialize by using the templated helper functions in &lt;<span class="NDLSystemFont">efd/SerializeRoutines.h</span>&gt;; these can serialize even the most complex data structures with a single method call and will reduce the chance of making common mistakes (which could introduce security vulnerabilities if marshalling data from untrusted sources).</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">io_ar</span></td>
    <td>The <span class="NDLSystemFont"><a href="efd__Archive.htm">Archive</a></span> to serialize to or from. </td>
</tr>

        </tbody>
    </table>
</div>


 
<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

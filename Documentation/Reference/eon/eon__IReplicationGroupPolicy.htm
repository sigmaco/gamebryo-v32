<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>eon::IReplicationGroupPolicy</title>
<!--(Begin Meta)================================================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Expedition" />
<meta name="Generator" content="DoxyConvert by Emergent Game Technologies - http://emergent.net" />

<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)==================================================================================-->
    
<!--(Begin Links)===============================================================================-->

<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=================================================================================-->

</head>
  
<!--(Body)======================================================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<p class="NDLRefHeadClassTitle">eon::IReplicationGroupPolicy</p>
<p class="NDLRefParentage">: public <span class="NDLSystemFont"><a href="../efd/efd__IBase.htm">efd::IBase</a></span></p>


<p class="NDLRefHeaderFile">&lt;IReplicationGroupPolicy.h&gt;</p>

<p class="NDLRefHead1" style="text-align: center; ">
<div class="FigureContainer">
  <img src="./images/classeon_1_1_i_replication_group_policy.gif" alt="Inheritance graph for eon::IReplicationGroupPolicy"/>
  <p class="FigureCaption">Inheritance graph for eon::IReplicationGroupPolicy</p>
</div>
</p>

<p class="NDLRefHead1">Description</p>
<p class="NDLNormal"><span class="NDLSystemFont">IReplicationGroupPolicy</span> defines the parameters for a replication group. </p>
<p class="NDLNormal">There is one policy for each of the 32 replication groups. The policies are controlled by configuration settings. </p>

<a name="public_static_methods"></a>
<p class="NDLRefHead1">Public Static Methods</p>


<a name="classeon_1_1_i_replication_group_policy_1a04816255cfda266315497781c1a69c7b"></a>
<p class="NDLRefMemberFunction">static <span class="NDLSystemFont">IReplicationGroupPolicy</span>*  GetReplicationGroupPolicy(<span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> groupIndex)</p>
<p class="NDLRefMemberDescription">Static accessors There are up to 32 possible policy instances. </p>
<p class="NDLRefMemberDetailedDescription">These static accessors can be used to get the various instances. If you are using custom policy objects then register your objects before calling Init, otherwise the system will automatically create <span class="NDLSystemFont"><a href="eon__GroupUpdatePolicy.htm">GroupUpdatePolicy</a></span> objects whenever a group is requested. Get the <span class="NDLSystemFont">IReplicationGroupPolicy</span> object for the specified group index.</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">groupIndex</span></td>
    <td>Index of the property group to get the policy of </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classeon_1_1_i_replication_group_policy_1a1b6e393ae2810d12eec21d45e874d9f9"></a>
<p class="NDLRefMemberFunction">static void  SetReplicationGroupPolicy(<br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> groupIndex, <br/><span class="NDLSystemFont">IReplicationGroupPolicy</span>* pGroupUpdatePolicy)</p>
<p class="NDLRefMemberDescription">Set the <span class="NDLSystemFont">IReplicationGroupPolicy</span> object for the specified group index. </p>
<p class="NDLRefMemberDetailedDescription">If registering a custom <span class="NDLSystemFont">IReplicationGroupPolicy</span> implementation you should call this prior to calling Init, otherwise default <span class="NDLSystemFont"><a href="eon__GroupUpdatePolicy.htm">GroupUpdatePolicy</a></span> objects will be automatically created.</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">groupIndex</span></td>
    <td>Index of the property group to set the policy of </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">pGroupUpdatePolicy</span></td>
    <td>The policy to assign to the specified group index </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classeon_1_1_i_replication_group_policy_1a14fa8fbbbadaa55079af67f22debe69a"></a>
<p class="NDLRefMemberFunction">static void  Init(<br/><span class="NDLSystemFont"><a href="../efd/efd__IConfigManager.htm">efd::IConfigManager</a></span>* pIConfigManager, <br/><span class="NDLSystemFont"><a href="../efd/efd__EnumManager.htm">efd::EnumManager</a></span>* pEnumManager)</p>
<p class="NDLRefMemberDescription">Read any config data from the ConfigManager. </p>
<p class="NDLRefMemberDetailedDescription">Standard options will be automatically parsed and set with the standard Generic Policy Options methods. If a policy needs to parse additional options they should override ReadConfiguration.</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">pIConfigManager</span></td>
    <td>The ConfgiManager pointer to read data from </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">pEnumManager</span></td>
    <td>The enumeration manager to allow setting quality of service values by name. </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classeon_1_1_i_replication_group_policy_1a928dd8f3b2f70c044b64f51b2ca8c0bc"></a>
<p class="NDLRefMemberFunction">virtual void  ReadConfiguration(const <span class="NDLSystemFont"><a href="../efd/efd__ISection.htm">efd::ISection</a></span>* pSection)</p>
<p class="NDLRefMemberDescription">Called by the Init method when a configuration section is provided for the given policy. </p>
<p class="NDLRefMemberDetailedDescription">This is not called if no configuration section is present. When called, the quality of service, minimum update delta, and update all policy settings will have already been read and applied so there is no need to call the default implementation, which does nothing. </p>

<a name="classeon_1_1_i_replication_group_policy_1a5af44c47ed0747fc755fba31abfece79"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a3f46b06120f84d47e33a25e39034ed8e">efd::QualityOfService</a></span>  GetQualityOfService() const</p>
<p class="NDLRefMemberDescription">Generic Policy Options These are the basic policy options that all policy implementations are expected to support. </p>
<p class="NDLRefMemberDetailedDescription">These can be extended by sub-classes but all subclasses are expected to support these. Get the QualityOfService for the specified property group </p>

<a name="classeon_1_1_i_replication_group_policy_1aca780d7ff26faf3375272676588a0e0d"></a>
<p class="NDLRefMemberFunction">void  SetQualityOfService(<span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a3f46b06120f84d47e33a25e39034ed8e">efd::QualityOfService</a></span> qos)</p>
<p class="NDLRefMemberDescription">Set the QualityOfService for the specified property group. </p>
<p class="NDLRefMemberDetailedDescription">This should only be set during initial setup and should not be changed once replication has begun.</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">qos</span></td>
    <td>The new Quality of Service </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classeon_1_1_i_replication_group_policy_1af44c49a0376b88398b90018793f80311"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a37c593debc73d82d7ddc571c725f0e2d">efd::TimeType</a></span>  GetMinUpdateDelta()</p>
<p class="NDLRefMemberDescription">Get the minimum amount of time between updates. </p>
<p class="NDLRefMemberDetailedDescription">Updates should never be generated more often that this time interval even though GenerateUpdate may be called more frequently. </p>

<a name="classeon_1_1_i_replication_group_policy_1ad62445780dbd71528b5548f9bfdc346f"></a>
<p class="NDLRefMemberFunction">void  SetMinUpdateDelta(<span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a37c593debc73d82d7ddc571c725f0e2d">efd::TimeType</a></span> minDelta)</p>
<p class="NDLRefMemberDescription">Set the minimum amount of time between updates. </p>
<p class="NDLRefMemberDetailedDescription">When using the default policy this can be changed at run-time and should begin to take immediately.</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">minDelta</span></td>
    <td>The minimum amount of time between updates. </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classeon_1_1_i_replication_group_policy_1a3c0b48c8b8bba6115a61148f2ad1989c"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  GetUpdateAll() const</p>
<p class="NDLRefMemberDescription">Get the policy option for updating all properties rather than only dirty properties. </p>
<p class="NDLRefMemberDetailedDescription">By default only the dirty properties are updated, when this option is set then it is requested that updates contain more than just the dirty properties. Exactly what that means is determined by the specific policy implementation. The default <span class="NDLSystemFont"><a href="eon__GroupUpdatePolicy.htm">GroupUpdatePolicy</a></span> implementation will send all non-default properties that are in the specified replication groups when this option is set. This policy option can be useful for small replication groups that are sent over unreliable categories. If you are using a reliable quality of service then it is recommended that this option be left off in order to reduce bandwidth. </p>

<a name="classeon_1_1_i_replication_group_policy_1a3836bea86faa67ba263094f809d0c1e5"></a>
<p class="NDLRefMemberFunction">void  SetUpdateAll(<span class="NDLSystemFont">bool</span> updateAll)</p>
<p class="NDLRefMemberDescription">Set the "update all" policy. </p>
<p class="NDLRefMemberDetailedDescription">See GetUpdateAll for details on this policy. When using the default policy this can be changed at run-time and should begin to take effect immediately.</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">updateAll</span></td>
    <td>A value indicating all property groups should be updated </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classeon_1_1_i_replication_group_policy_1a79c1fc18dc8fb7843c2dca4e784e04ae"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  GetTreatUpdatesAsDiscovers() const</p>
<p class="NDLRefMemberDescription">The the "treat updates as discovers" policy. </p>
<p class="NDLRefMemberDetailedDescription">When this policy is set all updates will be sent as if they are discovery requests. When used on an unreliable replication category this prevents loss of an initial discovery message from preventing the entity from ever being created. When using this policy the replica entity must be able to handle having only a partial state transfer as the updates will only contain dirty properties and out-of-order delivery or message loss can prevent some updates from being applied; you may wish to combine this policy with "update all" if the group also needs to ensure the properties are all updated together. </p>

<a name="classeon_1_1_i_replication_group_policy_1aba9e542799e1868b8016c58ccbded458"></a>
<p class="NDLRefMemberFunction">void  SetTreatUpdatesAsDiscovers(<span class="NDLSystemFont">bool</span> bSendDiscovers)</p>
<p class="NDLRefMemberDescription">Set the "treat updates as discovers" policy. </p>
<p class="NDLRefMemberDetailedDescription">See GetTreatUpdatesAsDiscovers for details on this policy. When using the default policy this can be changed at run-time and should begin to take effect immediately.</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">bSendDiscovers</span></td>
    <td>The "treat updates as discovers" policy value. </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classeon_1_1_i_replication_group_policy_1ae79332f4dec179655f690c78830a7e95"></a>
<p class="NDLRefMemberFunction">virtual void  BeginUpdate()</p>
<p class="NDLRefMemberDescription">Normal replication methods. </p>
<p class="NDLRefMemberDetailedDescription">Begin a cycle of replication updates. During the update cycle each dirty entity that uses the policy will make a call to generate either a discovery, an update, or a loss. The calls will be grouped by entity only, and not by replication category. Policies that wish to aggregate updates to a specific category may wish to prepare for a series of updates during this call. The default implementation does nothing. </p>

<a name="classeon_1_1_i_replication_group_policy_1a29f9c4707e00fa925046d7d325864457"></a>
<p class="NDLRefMemberFunction">virtual void  EndUpdate()</p>
<p class="NDLRefMemberDescription">End a cycle of replication updates. </p>
<p class="NDLRefMemberDetailedDescription">Policies that wish to aggregate updates can use this call to apply any cached data. The default implementation does nothing. </p>

<a name="classeon_1_1_i_replication_group_policy_1a4008c3f0058a1bf35dd686273e79aa78"></a>
<p class="NDLRefMemberFunction">virtual void  GenerateDiscovery(<br/>const <span class="NDLSystemFont"><a href="../efd/efd__ServiceManager.htm">efd::ServiceManager</a></span>* pServiceManager, <br/><span class="NDLSystemFont"><a href="eon__ReplicationProducerEntity.htm">ReplicationProducerEntity</a></span>* pEntity, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> groupIndex) = 0</p>
<p class="NDLRefMemberDescription">Called when an entity should be discovered as result of setting a replication category. </p>
<p class="NDLRefMemberDetailedDescription">The typical response is to generate a MessageWrapper&lt;<span class="NDLSystemFont"><a href="eon__EntityMessage.htm">EntityMessage</a></span>, kMSGID_EntityDiscoveryMessage&gt; message describing the entity being discovered and all non-default property values for the group. The message should be sent to the category returned by pEntity-&gt;GetReplicationCategory(groupIndex) using the quality of service specified for the policy.</p>
<p class="NDLRefMemberDetailedDescription">
<p class="NDLRefMemberDetailedDescription">The Replication Service can only handle <span class="NDLSystemFont"><a href="eon__EntityMessage.htm">EntityMessage</a></span> results. If you construct a policy that sends other message types then you need to extend or replace the Replication Service to handle the new message type.</p></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">pServiceManager</span></td>
    <td>The service manager for use in accessing any required services </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">pEntity</span></td>
    <td>The producer entity for which to generate a discovery </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">groupIndex</span></td>
    <td>The replication group that is being discovered </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classeon_1_1_i_replication_group_policy_1a7f4c5c631c4f42d7fd2a5f728f310399"></a>
<p class="NDLRefMemberFunction">virtual void  GenerateUpdate(<br/>const <span class="NDLSystemFont"><a href="../efd/efd__ServiceManager.htm">efd::ServiceManager</a></span>* pServiceManager, <br/><span class="NDLSystemFont"><a href="eon__ReplicationProducerEntity.htm">ReplicationProducerEntity</a></span>* pEntity, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> groupIndex) = 0</p>
<p class="NDLRefMemberDescription">Called when an entity is dirty and should be considered for updating. </p>
<p class="NDLRefMemberDetailedDescription">The typical response is to generate a MessageWrapper&lt;EntityMessage, kMSGID_EntityUpdateMessage&gt; message if enough time has passed since the last message was sent, or to do nothing if enough time has not passed. When generating an update the contents should include at least all dirty properties from the group and may optionally include additional property values based on specific poilicy needs.</p>
<p class="NDLRefMemberDetailedDescription">
<p class="NDLRefMemberDetailedDescription">The Replication Service can only handle <span class="NDLSystemFont"><a href="eon__EntityMessage.htm">EntityMessage</a></span> results. If you construct a policy that sends other message types then you need to extend or replace the Replication Service to handle the new message type.</p></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">pServiceManager</span></td>
    <td>The service manager for use in accessing any required services </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">pEntity</span></td>
    <td>The producer entity for which to generate an update </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">groupIndex</span></td>
    <td>The replication group that is being updated </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classeon_1_1_i_replication_group_policy_1aa86b69a58fb32f9478775fdb61b42a40"></a>
<p class="NDLRefMemberFunction">virtual void  GenerateLoss(<br/>const <span class="NDLSystemFont"><a href="../efd/efd__ServiceManager.htm">efd::ServiceManager</a></span>* pServiceManager, <br/><span class="NDLSystemFont"><a href="eon__ReplicationProducerEntity.htm">ReplicationProducerEntity</a></span>* pEntity, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> groupIndex, <br/><span class="NDLSystemFont"><a href="../efd/efd__Category.htm">efd::Category</a></span> oldCategory, <br/><span class="NDLSystemFont"><a href="../efd/efd__Category.htm">efd::Category</a></span> newCategory) = 0</p>
<p class="NDLRefMemberDescription">Called when an entity should be lost due to a category change. </p>
<p class="NDLRefMemberDetailedDescription">The typical response is to generate a MessageWrapper&lt;EntityMessage, kMSGID_EntityLossMessage&gt; message describing the entity being lost which should be sent to the oldCategory using the quality of service specified for the policy.</p>
<p class="NDLRefMemberDetailedDescription">
<p class="NDLRefMemberDetailedDescription">The Replication Service can only handle <span class="NDLSystemFont"><a href="eon__EntityMessage.htm">EntityMessage</a></span> results. If you construct a policy that sends other message types then you need to extend or replace the Replication Service to handle the new message type.</p></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">pServiceManager</span></td>
    <td>The service manager for use in accessing any required services </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">pEntity</span></td>
    <td>The producer entity for which to generate a loss </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">groupIndex</span></td>
    <td>The replication group that is being lost </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">oldCategory</span></td>
    <td>The category this entity is being lost from </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">newCategory</span></td>
    <td>The new category this entity is joining, if any </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classeon_1_1_i_replication_group_policy_1a5d51ee55c8450fb9955cebb38402f64c"></a>
<p class="NDLRefMemberFunction">virtual void  BeginP2PUpdate()</p>
<p class="NDLRefMemberDescription">Point-to-point Discovery methods These methods handle the special case where a point-to-point discovery has been requested. </p>
<p class="NDLRefMemberDetailedDescription">Unlike the normal discovery process the results from a point-to-point discovery are sent to a specified category on a specified quality of service rather than using the values from the policy itself. Begin a point-2-point discovery. The default implementation does nothing. </p>

<a name="classeon_1_1_i_replication_group_policy_1aae4173346bc88a5eb54f248194fe89eb"></a>
<p class="NDLRefMemberFunction">virtual void  EndP2PUpdate()</p>
<p class="NDLRefMemberDescription">End a point-2-point discovery. </p>
<p class="NDLRefMemberDetailedDescription">Policies that wish to aggregate updates can use this call to apply any cached data. The default implementation does nothing. </p>

<a name="classeon_1_1_i_replication_group_policy_1a55daf584ad9b30532a5d4e1c357cd528"></a>
<p class="NDLRefMemberFunction">virtual void  GenerateP2PDiscovery(<br/>const <span class="NDLSystemFont"><a href="../efd/efd__ServiceManager.htm">efd::ServiceManager</a></span>* pServiceManager, <br/><span class="NDLSystemFont"><a href="eon__ReplicationProducerEntity.htm">ReplicationProducerEntity</a></span>* pEntity, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span> groupIndex, <br/><span class="NDLSystemFont"><a href="../efd/efd__Category.htm">efd::Category</a></span> callbackChannel, <br/><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1a3f46b06120f84d47e33a25e39034ed8e">efd::QualityOfService</a></span> qos) = 0</p>
<p class="NDLRefMemberDescription">Called when an entity should be discovered as result of a late joiner subscribing to the replication channel. </p>
<p class="NDLRefMemberDetailedDescription">The typical response is to generate a MessageWrapper&lt;<span class="NDLSystemFont"><a href="eon__EntityMessage.htm">EntityMessage</a></span>, kMSGID_EntityDiscoveryMessage&gt; message describing the entity being discovered and all non-default property values for the group. The message should be sent to the specified category using the specified quality of service.</p>
<p class="NDLRefMemberDetailedDescription">
<p class="NDLRefMemberDetailedDescription">The Replication Service can only handle <span class="NDLSystemFont"><a href="eon__EntityMessage.htm">EntityMessage</a></span> results. If you construct a policy that sends other message types then you need to extend or replace the Replication Service to handle the new message type.</p></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">pServiceManager</span></td>
    <td>The service manager for use in accessing any required services </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">pEntity</span></td>
    <td>The producer entity for which to generate a discovery </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">groupIndex</span></td>
    <td>The replication group that is being discovered </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">callbackChannel</span></td>
    <td>The category to which any results should be sent </td>
</tr>
<tr>
    <td><span class="NDLSystemFont">qos</span></td>
    <td>The quality of service at which results should be sent </td>
</tr>

        </tbody>
    </table>
</div>


 
<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

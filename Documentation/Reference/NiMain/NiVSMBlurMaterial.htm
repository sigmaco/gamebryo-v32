<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>NiVSMBlurMaterial</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2"
type="text/javascript">
</script><script language="JavaScript1.2" type="text/javascript">
WriteNavLink(2);
</script>

<p class="NDLRefHeadClassTitle">NiVSMBlurMaterial</p>

<p class="NDLRefParentage">: public <a href=
"NiFragmentMaterial.htm">NiFragmentMaterial</a></p>

<p class="NDLRefHeaderFile">&lt;NiVSMBlurMaterial.h&gt;</p>

<p class="NDLRefHead1">Description</p>

<p><span class="NDLSystemFont">NiVSMBlurMaterial</span> is a
material pipeline used by the <a href=
"NiVSMShadowTechnique.htm"><span class=
"NDLSystemFont">NiVSMShadowTechnique</span></a> to perform a
horizontal and vertical Gaussian blur on a shadow map. Note that
this material does not support hardware instancing. It is only
meant to be applied to a full screen quad for performing
post-processing effects.</p>

<p class="NDLRefHead1">Constructors</p>

<p class="NDLRefMemberFunction">NiVSMBlurMaterial(<a href=
"NiMaterialNodeLibrary.htm">NiMaterialNodeLibrary</a>* pkLibrary,
bool bAutoCreateCaches = true)</p>

<p class="NDLRefMemberDescription">Create a default material
using the specified material node library. If <span class=
"NDLSystemFont">bAutoCreateCaches</span> is true, a cache is
created using the static renderer pointer.</p>

<p class="NDLRefHead1">Supported Member Functions</p>

<p class="NDLRefHead1">Protected Supported Member Functions</p>

<p class="NDLRefMemberFunction">virtual bool
GenerateDescriptor(const NiRenderObject* pkGeometry, const
NiPropertyState* pkState, const NiDynamicEffectState* pkEffects,
NiMaterialDescriptor&amp; kMaterialDesc)</p>

<p class="NDLRefMemberDescription">Inherited from
NiFragmentMaterial. Generate the descriptor object that matches
the state of this render object. This descriptor will be a
NiVSMBlurMaterialDescriptor object.</p>

<p class="NDLRefMemberFunction">virtual bool
GenerateVertexShadeTree(Context&amp; kContext,
NiGPUProgramDescriptor* pkDesc)</p>

<p class="NDLRefMemberDescription">Inherited from
NiFragmentMaterial. This derived implementation controls the
wiring of the vertex shader material nodes.</p>

<p class="NDLRefMemberFunction">virtual bool
GeneratePixelShadeTree(Context&amp; kContext, NiGPUProgramDescriptor*
pkDesc)</p>

<p class="NDLRefMemberDescription">Inherited from
NiFragmentMaterial. This derived implementation controls the
wiring of the pixel shader material nodes.</p>

<p class="NDLRefMemberFunction">virtual unsigned int
VerifyShaderPrograms(NiGPUProgram* pkVertexShader, NiGPUProgram*
pkGeometryShader, NiGPUProgram* pkPixelShader)</p>

<p class="NDLRefMemberDescription">This method takes the shader
programs generated by the shader generating functions and returns
RC_SUCCESS if they were created successfully.</p>

<p class="NDLRefMemberFunction">virtual bool
InsertTexture(Context&amp; kContext, NiMaterialResource* pkUV,
NiMaterialResource*&amp; pkOutputColor, NiMaterialNode*&amp; pkNode,
NiFixedString&amp; kString, unsigned int uiBlurKernel)</p>

<p class="NDLRefMemberDescription">This method facilitates adding
a user-defined blur function and blur kernel size. kString is the
name of the material node to use for the blur kernel. pkNode is
set to this node and pkOutputColor is set to the output of this
node. A base texture is added to the shade tree using the pkUV
texture set. The blur kernel size is set as an input to the blur
node.</p>

<p class="NDLRefMemberFunction">virtual bool
HandleTexGen(Context&amp; kContext, NiMaterialResource*
pkInputUVResource, NiMaterialResource*&amp; pkOutputUVResource, const
NiFixedString&amp; kMapName, unsigned int uiExtra,
NiVSMBlurMaterial::TexGenOutput eOutputType)</p>

<p class="NDLRefMemberDescription">This method handles the
transforming the UV coordinates from their input state to their
output state in the vertex shader.</p>

<p class="NDLRefMemberFunction">virtual bool
HandlePositionFragment( Context&amp; kContext, TransformType
eTransType, NiMaterialResource*&amp; pkVertWorldPos,
NiMaterialResource*&amp; pkWorldMatrix)</p>

<p class="NDLRefMemberDescription">This method deals with
generating the world position fragment using the technique
specified in the NiVSMBlurMaterial::TransformType enumeration.
This method is called when constructing the vertex shade
tree.</p>

<p class="NDLRefMemberFunction">virtual bool
HandleViewProjectionFragment(Context&amp; kContext, bool
bForceViewPos, NiMaterialResource* pkVertWorldPos,
NiMaterialResource*&amp; pkVertOutProjectedPos, NiMaterialResource*&amp;
pkVertOutViewPos)</p>

<p class="NDLRefMemberDescription">This method applies the view
projection matrix to the world position. If requested, this
method will generate resources for the computed view position.
This method is called when constructing the vertex shade
tree.</p>

<p class="NDLRefMemberFunction">virtual bool
SetupTransformPipeline(Context&amp; kContext, NiMaterialResource*
pkVertOutProjPos, NiVSMBlurVertexProgramDescriptor* pkVertDesc,
bool bForceView, bool bForceViewPos, NiMaterialResource*&amp;
pkWorldPos, NiMaterialResource*&amp; pkViewPos, NiMaterialResource*&amp;
pkProjectedPos, NiMaterialResource*&amp; pkWorldNormal,
NiMaterialResource*&amp; pkWorldView)</p>

<p class="NDLRefMemberDescription">This method encapsulates the
vertex position/normal/binormal/tangent transformation pipeline.
If requested, this method will generate the world view
vector.</p>

<p class="NDLRefMemberFunction">virtual ReturnCode
GenerateShaderDescArray( NiMaterialDescriptor*
pkMaterialDescriptor, RenderPassDescriptor* pkRenderPasses,
unsigned int uiMaxCount, unsigned int&amp; uiCountAdded)</p>

<p class="NDLRefMemberDescription">Inherited from
NiFragmentMaterial. By default this creates one render pass with
an NiStandardPixelProgramDescriptor and an
NiStandardVertexProgramDescriptor.</p>

<p class="NDLRefMemberFunction">virtual NiShader*
CreateShader(NiMaterialDescriptor* pkDesc)</p>

<p class="NDLRefMemberDescription">Inherited from
NiFragmentMaterial. Creates the NiShader that will be filled in
by later methods.</p>

<p class="NDLRefMemberFunction">virtual bool
SetupPackingRequirements(NiShader* pkShader,
NiMaterialDescriptor* pkMaterialDescriptor, RenderPassDescriptor*
pkRenderPasses, unsigned int uiCount)</p>

<p class="NDLRefMemberDescription">Inherited from
NiFragmentMaterial. Configures the shader's packing structures
for the requirements of this instance of the material. Note that
this method is considered deprecated, and GetVertexInputSemantics
should be used instead.</p>

<p class="NDLRefHead1">Notes</p><a name="Transform_Type" id=
"Transform_Type"></a>

<p class="NDLRefHead2">Transform Type</p>

<p>This enumeration determines how this material deals with
transformations.</p>
<!--(Table)=========================================================-->

<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class=
            "NDLSystemFont">TRANSFORM_DEFAULT</span></td>

            <td>Traditional vertex
            transformations.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">TRANSFORM_SKINNED</span></td>

            <td>Skinned vertex
            transformations wherein bones are chosen from a
            palette of transforms using per-vertex indices.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">TRANSFORM_RESERVED</span></td>

            <td>This value is reserved and
            should not be used.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">TRANSFORM_INSTANCED</span></td>

            <td>Instanced vertex
            transformations.</td>
        </tr>
    </tbody>
</table><a name="TexGenOutput" id="TexGenOutput"></a>

<p class="NDLRefHead2">TexGenOutput</p>

<p>This enumeration determines how this material deals with
texture coordinate transformation..</p>
<!--(Table)=========================================================-->

<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class=
            "NDLSystemFont">TEX_OUT_PASSTHRU</span></td>

            <td>Coordinate used as-is.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">TEX_OUT_TRANSFORM</span></td>

            <td>Coordinate has texture
            transform applied.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">TEX_OUT_PARALLEL_PROJECT</span></td>

            <td>Coordinate has parallel
            projection applied.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">TEX_OUT_PERSPECTIVE_PROJECT</span></td>

            <td>Coordinate has perspective
            projection applied.</td>
        </tr>
    </tbody>
</table>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

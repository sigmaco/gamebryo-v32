<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>NiTPointerListBase</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script> <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<p class="NDLRefHeadClassTitle">NiTPointerListBase</p>

<p class="NDLRefParentage">:
public <a href="NiTListBase.htm">NiTListBase</a></p>

<p class="NDLRefHeaderFile">&lt;NiTPointerListBase.h&gt;</p>

<p class="NDLRefHead1">Description</p>

<p>This is an abstract base class implementation of a doubly-linked list.</p>

<p class="NDLRefHead1">Supported
Member Functions</p>

<p class="NDLRefMemberFunction">void
AddHead(const T&amp; element)</p>

<p class="NDLRefMemberFunction">void
AddTail(const T&amp; element)</p>

<p class="NDLRefMemberDescription">Add
the given item as the first and last items on the list, respectively. Note that
the assignment operator is used to copy the items into the list. The element is
not checked to see if it is already on the list.</p>

<p class="NDLRefMemberFunction">NiTListIterator
InsertBefore(NiTListIterator kPos, const T&amp; element)</p>

<p class="NDLRefMemberFunction">NiTListIterator
InsertAfter(NiTListIterator kPos, const T&amp; element)</p>

<p class="NDLRefMemberDescription">Inserts
the given element before and after the element pointed to by the given
iterator, respectively. <em>The given iterator must not be <span class="NDLSystemFont">NULL</span></em>.</p>

<p class="NDLRefMemberFunction">const
T&amp; GetHead() const</p>

<p class="NDLRefMemberFunction">const
T&amp; GetTail() const</p>

<p class="NDLRefMemberDescription">Return
the items that are the first and last elements on the list, respectively. <em>These
functions must not be called on an empty list!</em></p>

<p class="NDLRefMemberFunction">const
T&amp; Get(NiTListIterator kPos) const</p>

<p class="NDLRefMemberDescription">Return
the object pointed to by the given iterator. The given iterator <em>must not</em> be <span class="NDLSystemFont">NULL</span>.</p>

<p class="NDLRefMemberFunction">const
T&amp; GetNext(NiTListIterator&amp; kPos) const</p>

<p class="NDLRefMemberFunction">const
T&amp; GetPrev(NiTListIterator&amp; kPos) const</p>

<p class="NDLRefMemberDescription">Return
the object pointed to by the given iterator, and <em>then</em> advance or retreat
the iterator by one element. <em>The given iterator must not be <span class="NDLSystemFont">NULL</span></em>.</p>

<p class="NDLRefMemberFunction">T
RemoveHead()</p>

<p class="NDLRefMemberFunction">T
RemoveTail()</p>

<p class="NDLRefMemberDescription">Remove
the first and last list items, respectively. They return objects, not
references, and thus use the copy constructor to create the returned object.
The removed element's storage is not deleted (and thus the destructor for the
element is not called), but the element is set equal to <span class="NDLSystemFont">T(0)</span>, making it safe to use
with smart pointers. <em>These functions must not be called on an empty list!</em></p>

<p class="NDLRefMemberFunction">T
Remove(const T&amp; element)</p>

<p class="NDLRefMemberDescription">Removes
the first instance of the given object on the list (if any), and returns the
object. The removed element's storage is not deleted (and thus the destructor
for the element is not called), but the element is set equal to <span class="NDLSystemFont">T(0)</span>, making it safe to use
with smart pointers. </p>

<p class="NDLRefMemberFunction">T
RemovePos(NiTListIterator&amp; kPos)</p>

<p class="NDLRefMemberDescription">This
function removes the list element to which the iterator points. <em>The iterator
must point to an element of the list</em>. The removed element's storage is not
deleted (and thus the destructor for the element is not called), but the
element is set equal to <span class="NDLSystemFont">T(0)</span>,
making it safe to use with smart pointers. The removed object is returned.</p>

<p class="NDLRefMemberFunction">NiTListIterator
FindPos(const T&amp; element, NiTListIterator kStart = 0) const</p>

<p class="NDLRefMemberDescription">Returns
an iterator that points to the first instance of the given item in the list
that follows the given starting position. If <span class="NDLSystemFont">NULL</span> (the default) is sent as
the starting iterator value, then the search starts at the head of the list.
The function returns a <span class="NDLSystemFont">NULL</span>
iterator if the object does not exist in the given part of the list. </p>

<p class="NDLRefHead1">Notes</p>

<p>The template type T must satisfy the following requirements:</p>

<ul>
  <li>T must have a "zero" element (i.e., T var; var = 0; is supported).</li>
  <li>The default constructor for T must exist and create the "zero" element. The constructor must also handle all necessary actions for constructing elements. That is, the template array class cannot make any post-construction member calls that are specific to class T.</li>
  <li>Copy constructor and assignment operator must work properly.</li>
  <li>The destructor must handle all necessary actions for destroying elements. That is, the template list class cannot make any pre-destruction member calls that are specific to class T.</li>
  <li>bool operator== (const T&amp;);</li>
  <li>bool operator!= (const T&amp;);</li>
</ul>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

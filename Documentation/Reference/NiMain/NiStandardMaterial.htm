<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>NiStandardMaterial</title>
<!--(Begin Meta)================================================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)==================================================================================-->
    
<!--(Begin Links)===============================================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=================================================================================-->

</head>

<!--(Begin Body)================================================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript">
</script><script language="JavaScript1.2" type="text/javascript">
WriteNavLink(2);
</script>

<p class="NDLRefHeadClassTitle">NiStandardMaterial</p>

<p class="NDLRefParentage">: public <a href="NiFragmentMaterial.htm">NiFragmentMaterial</a></p>

<p class="NDLRefHeaderFile">&lt;NiStandardMaterial.h&gt;</p>

<p class="NDLRefHead1">Description</p>

<p><span class="NDLSystemFont">NiStandardMaterial</span> is a material pipeline that encapsulates
the Gamebryo default pipeline. This pipeline is discussed in more detail in the <a href=
"../../Programmer/NiMaterial/NiStandardMaterial.htm">Programmer's Guide</a>.</p>

<p class="NDLRefHead1">Public Constructors</p>

<p class="NDLRefMemberFunction">NiStandardMaterial(<a href=
"NiMaterialNodeLibrary.htm">NiMaterialNodeLibrary</a>* pkLibrary, bool bAutoCreateCaches =
true)</p>

<p class="NDLRefMemberDescription">Create a default material using the specified material node
library. If <span class="NDLSystemFont">bAutoCreateCaches</span> is true, a cache is created using
the static renderer pointer.</p>

<p class="NDLRefHead1">Protected Constructors</p>

<p>These functions are for use by derived classes.</p>

<p class="NDLRefMemberFunction">NiStandardMaterial(const <a href=
"NiFixedString.htm">NiFixedString</a>&amp; kName, NiMaterialNodeLibrary* pkLibrary, unsigned int
uiVertexVersion, unsigned int uiGeometryVersion, unsigned int uiPixelVersion, bool
bAutoCreateCaches)</p>

<p class="NDLRefMemberDescription">This function takes the same parameters as its parent class
<a href="NiFragmentMaterial.htm"><span class="NDLSystemFont">NiFragmentMaterial</span></a>. It
creates a standard material using the given node library. It names the material <span class=
"NDLSystemFont">kName</span>. If <span class="NDLSystemFont">bAutoCreateCaches</span> is true, then
a cache for this type of material will be created using the static renderer pointer. The version
numbers will be stored in the cache so that when a material is updated to a newer version, older
cached shaders will be invalidated and then regenerated.</p>

<p class="NDLRefMemberFunction">NiStandardMaterial(const <a href=
"NiFixedString.htm">NiFixedString</a>&amp; kName, <a href=
"NiMaterialNodeLibrary.htm">NiMaterialNodeLibrary</a>* pkLibrary, bool bAutoCreateCaches)</p>

<p class="NDLRefMemberDescription">This constructor creates a default material using the specified
material node library named <span class="NDLSystemFont">kName</span>. If <span class=
"NDLSystemFont">bAutoCreateCaches</span> is true, a cache is created using the static renderer
pointer. Unlike the other protected constructor which takes explicit version numbers (for derived
classes that implement their own versioning scheme), this function just uses the shader version
numbers internal to <span class="NDLSystemFont">NiStandardMaterial</span>.</p>

<p class="NDLRefHead1">Public Supported Member Functions</p>

<p class="NDLRefMemberFunction">void SetForcePerPixelLighting(bool bForce)</p>

<p class="NDLRefMemberFunction">bool GetForcePerPixelLighting() const</p>

<p class="NDLRefMemberDescription">Get and set whether or not the lighting is done per-pixel.</p>

<p class="NDLRefMemberFunction">void SetSaturateShading(bool bForce)</p>

<p class="NDLRefMemberFunction">bool GetSaturateShading() const</p>

<p class="NDLRefMemberDescription">Get and set whether or not the lighting results are
saturated.</p>

<p class="NDLRefMemberFunction">void SetSaturateTextures(bool bForce)</p>

<p class="NDLRefMemberFunction">bool GetSaturateTextures() const</p>

<p class="NDLRefMemberDescription">Get and set whether or not textures are saturated whenever an
operation is performed.</p>

<p class="NDLRefMemberFunction">virtual void AddDefaultFallbacks()</p>

<p class="NDLRefMemberDescription">Inherited from <a href="NiFragmentMaterial.htm"><span class=
"NDLSystemFont">NiFragmentMaterial</span></a>. Creates the default fallback functions.</p>

<p class="NDLRefHead1">Protected Supported Member Functions</p>

<p class="NDLRefHead2">Infrastructure Methods</p>

<p class="NDLRefMemberFunction">virtual <a href="NiShader.htm"><span class=
"NDLSystemFont">NiShader</span></a>* CreateShader(NiMaterialDescriptor* pkDesc)</p>

<p class="NDLRefMemberDescription">Inherited from <a href="NiFragmentMaterial.htm"><span class=
"NDLSystemFont">NiFragmentMaterial</span></a>. Creates the <a href="NiShader.htm"><span class=
"NDLSystemFont">NiShader</span></a> that will be filled in by later methods.</p>

<p class="NDLRefMemberFunction">virtual bool SetupPackingRequirements(<a href=
"NiShader.htm">NiShader</a>* pkShader, <a href="NiMaterialDescriptor.htm">NiMaterialDescriptor</a>*
pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiCount)</p>

<p class="NDLRefMemberDescription">Inherited from <a href="NiFragmentMaterial.htm"><span class=
"NDLSystemFont">NiFragmentMaterial</span></a>. Configures the shader's packing structures for the
requirements of this instance of the material. Note that this method is considered deprecated, and
<span class="NDLSystemFont">GetVertexInputSemantics</span> should be used instead.</p>

<p class="NDLRefMemberFunction">virtual bool GenerateDescriptor(const <a href=
"NiRenderObject.htm">NiRenderObject</a>* pkGeometry, const <a href=
"NiPropertyState.htm">NiPropertyState</a>* pkState, const <a href=
"NiDynamicEffectState.htm">NiDynamicEffectState</a>* pkEffects, <a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>&amp; kMaterialDesc)</p>

<p class="NDLRefMemberDescription">Inherited from <a href="NiFragmentMaterial.htm"><span class=
"NDLSystemFont">NiFragmentMaterial</span></a>. Generate the descriptor object that matches the
state of this geometry. This descriptor will be a <a href=
"NiStandardMaterialDescriptor.htm"><span class=
"NDLSystemFont">NiStandardMaterialDescriptor</span></a> object.</p>

<p class="NDLRefMemberFunction">virtual bool AddResourceToShaderConstantMap(<a href=
"NiShader.htm">NiShader</a>* pkShader, <a href="NiShaderConstantMap.htm">NiShaderConstantMap</a>*
pkMap, <a href="NiMaterialResource.htm">NiMaterialResource</a>* pkRes, <a href=
"NiGPUProgramDescriptor.htm">NiGPUProgramDescriptor</a>* pkVertexDesc, <a href=
"NiGPUProgramDescriptor.htm">NiGPUProgramDescriptor</a>* pkGeometryDesc, <a href=
"NiGPUProgramDescriptor.htm">NiGPUProgramDescriptor</a>* pkPixelDesc, const <a href=
"NiTObjectSet.htm">NiTObjectSet</a>&lt;ObjectResourceOffset&gt;&amp; kObjectOffsets, unsigned int
uiPass, <a href="NiGPUProgram.htm#ProgramType">NiGPUProgram::ProgramType</a> eCurrentType)</p>

<p class="NDLRefMemberDescription">Inherited from <a href="NiFragmentMaterial.htm"><span class=
"NDLSystemFont">NiFragmentMaterial</span></a>. This derived implementation adds special case code
for texture transforms in the vertex program to properly map up to predefines for the pixel
program.</p>

<p class="NDLRefMemberFunction">virtual bool GeneratePixelShadeTree(Context&amp; kContext,
NiGPUProgramDescriptor* pkDesc)</p>

<p class="NDLRefMemberDescription">This method controls the wiring of the pixel shader material
nodes.</p>

<p class="NDLRefMemberFunction">virtual bool GenerateGeometryShadeTree(Context&amp; kContext,
NiGPUProgramDescriptor* pkDesc)</p>

<p class="NDLRefMemberDescription">This method controls the wiring of the geometry shader material
nodes.</p>

<p class="NDLRefMemberFunction">virtual bool GenerateVertexShadeTree(Context&amp; kContext,
NiGPUProgramDescriptor* pkDesc)</p>

<p class="NDLRefMemberDescription">This method controls the wiring of the vertex shader material
nodes.</p>

<p class="NDLRefMemberFunction">virtual ReturnCode GenerateShaderDescArray(<a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>* pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiMaxCount, unsigned int&amp; uiCountAdded)</p>

<p class="NDLRefMemberDescription">Inherited from <a href="NiFragmentMaterial.htm"><span class=
"NDLSystemFont">NiFragmentMaterial</span></a>. By default this creates one render pass with a
<a href="NiStandardPixelProgramDescriptor.htm"><span class=
"NDLSystemFont">NiStandardPixelProgramDescriptor</span></a> and a <span class=
"NDLSystemFont"><a href=
"NiStandardVertexProgramDescriptor.htm">NiStandardVertexProgramDescriptor</a></span>.</p>

<p class="NDLRefMemberFunction">virtual unsigned int VerifyShaderPrograms(<a href=
"NiGPUProgram.htm">NiGPUProgram</a>* pkVertexShader, <a href="NiGPUProgram.htm">NiGPUProgram</a>*
pkGeometryShader, <a href="NiGPUProgram.htm">NiGPUProgram</a>* pkPixelShader)</p>

<p class="NDLRefMemberDescription">This method takes the shader programs generated by the shader
generating functions and returns <span class="NDLSystemFont">RC_SUCCESS</span> if they were created
successfully.</p>

<p class="NDLRefHead2">Vertex Data Methods</p>

<p class="NDLRefMemberFunction">virtual bool HandlePositionFragment(Context&amp; kContext, <a href=
"NiStandardMaterial.htm#Transform_Type">TransformType</a> eTransType, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkVertWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldMatrix)</p>

<p class="NDLRefMemberDescription">This method deals with generating the world position
fragment.</p>

<p class="NDLRefMemberFunction">virtual bool HandleNormalFragment(Context&amp; kContext, <a href=
"NiStandardMaterial.htm#NormalType">NormalType</a> eNormType, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldMatrix, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkVertWorldNorm, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkVertWorldBiNorm, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkVertWorldTangent)</p>

<p class="NDLRefMemberDescription">This method deals with generating the world normal and
potentially binormal and tangent.</p>

<p class="NDLRefMemberFunction">virtual bool HandlePostWorldTransform(Context&amp; kContext,
<a href="NiGPUProgramDescriptor.htm">NiGPUProgramDescriptor</a>* pkVertexProgram, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkVertWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkVertWorldNorm)</p>

<p class="NDLRefMemberDescription">This method deals with manipulating the position after the world
transform has been computed. This method is here as a hook for inheritance only.</p>

<p class="NDLRefMemberFunction">virtual bool HandleViewProjectionFragment(Context&amp; kContext,
bool bForceViewPos, <a href="NiMaterialResource.htm">NiMaterialResource</a>* pkVertWorldPos,
<a href="NiMaterialResource.htm">NiMaterialResource</a>* pkVertOutProjectedPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkVertOutViewPos)</p>

<p class="NDLRefMemberDescription">This method applies the view projection matrix to the world
position. If requested, this method will generate resources for the computed view position.</p>

<p class="NDLRefMemberFunction">virtual bool HandleViewVectorFragment(Context&amp; kContext,
<a href="NiMaterialResource.htm">NiMaterialResource</a>* pkWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldNorm,<a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldBinorm, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldTangent, bool bComputeTangent, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldViewVector, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkTangentViewVector)</p>

<p class="NDLRefMemberDescription">This method generates the view vector and if requested generates
the view vector in a specific tangent space.</p>

<p class="NDLRefMemberFunction">virtual bool HandleReflectionVectorFragment(Context&amp; kContext,
<a href="NiMaterialResource.htm">NiMaterialResource</a>* pkWorldNorm, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldViewVector, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldReflectionVector)</p>

<p class="NDLRefMemberDescription">This method handles computing the world space reflection vector
from the world normal and world view vector.</p>

<p class="NDLRefMemberFunction">virtual bool SetupTransformPipeline(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVertOutProjPos, <a href=
"NiStandardVertexProgramDescriptor.htm">NiStandardVertexProgramDescriptor</a>* pkVertDesc, bool
bForceView, bool bForceViewPos, <a href="NiMaterialResource.htm">NiMaterialResource</a>*&amp;
pkWorldPos, <a href="NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkViewPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkProjectedPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldNormal, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldView)</p>

<p class="NDLRefMemberDescription">This method encapsulates the vertex/normal/binormal/tangent
pipeline. If requested, this method will generate the world view vector.</p>

<p class="NDLRefHead2">Material And Lighting Functions</p>

<p class="NDLRefMemberFunction">virtual bool HandleInitialSpecAmbDiffEmissiveColor(Context&amp;
kContext, bool bSpecularOn, <a href=
"NiStandardMaterial.htm#AmbDiffEmissiveEnum1">AmbDiffEmissiveEnum</a> eADF, LightingModeEnum
eLightingMode, <a href="NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseColorRes,
<a href="NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkSpecularColorRes, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkSpecularPowerRes, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkAmbientColorRes, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkEmissiveColorRes, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkOpacityRes)</p>

<p class="NDLRefMemberDescription">This method adds the appropriate fragment to initialize the
ambient/diffuse/specular/emissive colors for the pixel shader.</p>

<p class="NDLRefMemberFunction">virtual bool HandleCalculateFog(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkViewPos, <a href=
"NiStandardMaterial.htm#Fog">Fog</a> eFogType)</p>

<p class="NDLRefMemberDescription">This method sets up the fogging pipeline in the vertex
shader.</p>

<p class="NDLRefMemberFunction">virtual bool HandleLighting(Context&amp; kContext, bool bSpecular,
unsigned int uiNumPoint, unsigned int uiNumDirectional, unsigned int uiNumSpot, unsigned int
uiShadowBitfield, <a href="NiMaterialResource.htm">NiMaterialResource</a>* pkWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldNorm, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkViewVector, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkSpecularPower, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkSpecularAccum)</p>

<p class="NDLRefMemberDescription">This method encapsulates the lighting pipeline. For each light
specified, <span class="NDLSystemFont">HandleLight</span> will be called.</p>

<p class="NDLRefMemberFunction">virtual bool HandleShadow(Context&amp; kContext, unsigned int
uiLight, <a href="NiStandardMaterial.htm#LightType">LightType</a> eType, unsigned int
uiLightByType, <a href="NiMaterialResource.htm">NiMaterialResource</a>* pkWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldNorm, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkShadow)</p>

<p class="NDLRefMemberDescription">This method encapsulates adding a shadow per light. <span class=
"NDLSystemFont">uiLight</span> is the overall light index. <span class="NDLSystemFont">eType</span>
is the type of this particular light. <span class="NDLSystemFont">uiLightByType</span> is the light
index for this particular type of light. <span class="NDLSystemFont">pkWorldPos</span> and
<span class="NDLSystemFont">pkWorldNorm</span> are the input world position and normal vectors.
<span class="NDLSystemFont">pkShadow</span> is the percentage that this pixel fragment is in shadow
for this light.</p>

<p class="NDLRefMemberFunction">virtual bool HandleLight(Context&amp; kContext, unsigned int
uiLight, <a href="NiStandardMaterial.htm#LightType">LightType</a> eType, unsigned int
uiLightByType, <a href="NiMaterialResource.htm">NiMaterialResource</a>* pkWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldNorm, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkViewVector, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkSpecularPower, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkAmbientAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkSpecularAccum, bool bSpecular,
NiMaterialResource* pkShadow)</p>

<p class="NDLRefMemberDescription">This method handles adding a single light.</p>

<p class="NDLRefMemberFunction">virtual bool HandleApplyFog(Context&amp; kContext, <a href=
"NiStandardPixelProgramDescriptor.htm">NiStandardPixelProgramDescriptor</a>* pkPixDesc, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUnfoggedColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkFogOutput)</p>

<p class="NDLRefMemberDescription">This method handles applying fog in the pixel shader.</p>

<p class="NDLRefMemberFunction">virtual bool HandleFinalVertexOutputs(Context&amp; kContext,
NiStandardVertexProgramDescriptor* pkVertDesc, NiMaterialResource* pkWorldPos, NiMaterialResource*
pkWorldNormal, NiMaterialResource* pkWorldReflect, NiMaterialResource* pkViewPos,
NiMaterialResource* pkProjectedPos)</p>

<p class="NDLRefMemberDescription">This method controls any additional outputs the user wishes to
send from the vertex shader. By default, it calls HandleVertexUVSets and HandleCalculateFog, but a
user may override or extend this ability in a derived class.</p>

<p class="NDLRefMemberFunction">virtual bool HandleVertexLightingAndMaterials(Context&amp;
kContext, NiStandardVertexProgramDescriptor* pkVertexDesc, NiMaterialResource* pkWorldPos,
NiMaterialResource* pkWorldNormal, NiMaterialResource* pkWorldView)</p>

<p class="NDLRefMemberDescription">This method controls the lighting and material property pipeline
for the vertex shader. It controls the application of per-vertex lighting or alternatively does the
per-vertex work needed for per-pixel lighting.</p>

<p class="NDLRefMemberFunction">virtual bool HandlePixelInputs(Context&amp; kContext,
NiStandardPixelProgramDescriptor* pkPixelDesc, NiMaterialResource*&amp; pkPixelWorldPos,
NiMaterialResource*&amp; pkPixelWorldNorm, NiMaterialResource*&amp; pkPixelWorldBinormal,
NiMaterialResource*&amp; pkPixelWorldTangent, NiMaterialResource*&amp; pkPixelWorldViewVector,
NiMaterialResource*&amp; pkPixelTangentViewVector)</p>

<p class="NDLRefMemberDescription">This method controls the input data structure creation to the
pixel shader for any non-UV parameters, including the world position, world normal, world binormal,
world tangent, world view, and tangent view vectors, based on the state of the pixel descriptor.
Variables are only instantiated if they are requested by the descriptor.</p>

<p class="NDLRefMemberFunction">virtual bool HandlePixelMaterialInitialValues(Context&amp;
kContext, NiStandardPixelProgramDescriptor* pkPixelDesc, unsigned int uiPixelLightCount, bool
bSpecular, LightingModeEnum&amp; eLightingMode, NiMaterialResource*&amp; pkMatDiffuse,
NiMaterialResource*&amp; pkMatSpecular, NiMaterialResource*&amp; pkSpecularPower,
NiMaterialResource*&amp; pkGlossiness, NiMaterialResource*&amp; pkMatAmbient,
NiMaterialResource*&amp; pkMatEmissive, NiMaterialResource*&amp; pkTexDiffuseAccum,
NiMaterialResource*&amp; pkTexSpecularAccum, NiMaterialResource*&amp; pkDiffuseAccum,
NiMaterialResource*&amp; pkSpecularAccum, NiMaterialResource*&amp; pkOpacityAccum,
NiMaterialResource*&amp; pkLightDiffuseAccum, NiMaterialResource*&amp; pkLightSpecularAccum,
NiMaterialResource*&amp; pkLightAmbientAccum)</p>

<p class="NDLRefMemberDescription">This method is called by GeneratePixelShadeTree to initialize
most of the material variables for the texture and lighting pipelines. This also includes using the
correct per-vertex parameters for per-pixel or per-vertex lighting. Variables are only instantiated
if they are requested by the descriptor.</p>

<p class="NDLRefMemberFunction">virtual bool HandleColorAccumulation(Context&amp; kContext,
NiStandardPixelProgramDescriptor* pkPixelDesc, NiMaterialResource* pkMatEmissive,
NiMaterialResource* pkMatDiffuse, NiMaterialResource* pkMatAmbient, NiMaterialResource*
pkMatSpecular, NiMaterialResource* pkLightSpecularAccum, NiMaterialResource* pkLightDiffuseAccum,
NiMaterialResource* pkLightAmbientAccum, NiMaterialResource* pkGlossiness, NiMaterialResource*
pkTexDiffuseAccum, NiMaterialResource* pkTexSpecularAccum, LightingModeEnum eLightingMode,
NiMaterialResource*&amp; pkSpecularAccum, NiMaterialResource*&amp; pkDiffuseAccum)</p>

<p class="NDLRefMemberDescription">This method controls the combination of the shading coefficients
from a material, textures, and lighting. This also handles the differences in computation needed
for per-pixel and per-vertex lighting.</p>

<p class="NDLRefMemberFunction">virtual bool HandleFinalPixelOutputs(Context&amp; kContext,
NiStandardPixelProgramDescriptor* pkPixDesc, NiMaterialResource* pkDiffuseAccum,
NiMaterialResource* pkSpecularAccum, NiMaterialResource* pkOpacityAccum)</p>

<p class="NDLRefMemberDescription">This is the final method called when generating a pixel shade
tree and controls how the data is finally written to the pixel shader outputs.</p>

<p class="NDLRefHead2">UV Set Functions</p>

<p class="NDLRefMemberFunction">virtual <a href="NiFixedString.htm">NiFixedString</a>
GenerateUVSetName(unsigned int uiIndex)</p>

<p class="NDLRefMemberDescription">This method handles generating a UV set name by index.</p>

<p class="NDLRefMemberFunction">virtual bool HandleVertexUVSets(Context&amp; kContext,
NiStandardVertexProgramDescriptor* pkVertDesc, NiMaterialResource* pkWorldPos, NiMaterialResource*
pkWorldNormal, NiMaterialResource* pkWorldReflect)</p>

<p class="NDLRefMemberDescription">This method controls the UV coordinate generation pipeline for
the vertex shader. This covers passing through or transforming input UVs as well as procedurally
generating UV for projected lights/shadows/etc.</p>

<p class="NDLRefMemberFunction">virtual bool HandlePixelUVSets(Context&amp; kContext,
NiStandardPixelProgramDescriptor* pkPixelDesc, NiMaterialResource** ppkUVSets, unsigned int
uiMaxUVIndex, unsigned int&amp; uiNumStandardUVs, unsigned int&amp; uiDynamicEffectCount)</p>

<p class="NDLRefMemberDescription">This method is called by GeneratePixelShadeTree to initialize
the UV sets output from the vertex shader. The input array is allocated by the calling function,
but is filled in by this method. Additionally, the number of input simple UVs and number of input
dynamic effect UVs must be returned so that later steps in the texturing pipeline can find their UV
sets.</p>

<p class="NDLRefMemberFunction">virtual bool HandleTextureUVSets(Context&amp; kContext, <a href=
"NiStandardVertexProgramDescriptor.htm">NiStandardVertexProgramDescriptor</a>* pkVertexDesc,
<a href="NiMaterialResource.htm">NiMaterialResource</a>** apkOutputUVResources, size_t
stOutputUVMax, unsigned int&amp; uiNextUVIndex)</p>

<p class="NDLRefMemberDescription">This method generates the UV coordinate array for use by
textures in the vertex shader.</p>

<p class="NDLRefMemberFunction">virtual bool HandleTextureUVSetGen(Context&amp; kContext,
NiMaterialResource* pkInputUVResource, NiMaterialResource*&amp; pkOutputUVResource, const
NiFixedString&amp; kMapName, unsigned int uiExtra, NiStandardMaterial::TexGenOutput
eOutputType)</p>

<p class="NDLRefMemberDescription">This is the lowest-level method for creating UVs for generic
texture sampling by either passing-through UV coordinates or applying a texture transformation. It
is called from HandleTextureUVSets.</p>

<p class="NDLRefMemberFunction">virtual bool HandleTextureEffectUVSets(Context&amp; kContext,
<a href="NiMaterialResource.htm">NiMaterialResource</a>** apkOutputUVResources, size_t
stOutputUVMax, <a href="NiMaterialResource.htm">NiMaterialResource</a>* pkWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldNorm, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldReflection, <a href=
"NiStandardMaterial.htm#TexEffectType">TexEffectType</a> eEnvironmentMapType, unsigned int
uiProjectedLightCount, unsigned int uiProjectedLightTypes, unsigned int uiProjectedShadowCount,
unsigned int uiProjectedShadowTypes, unsigned int&amp; uiNextUVIndex)</p>

<p class="NDLRefMemberDescription">This method generates the UV coordinates for use by texture
effects in the vertex or pixel shader.</p>

<p class="NDLRefMemberFunction">virtual bool HandleTextureEffectUVSetGen(Context&amp; kContext,
<a href="NiMaterialResource.htm">NiMaterialResource</a>* pkWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldNorm, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldReflection, <a href=
"NiShaderAttributeDesc.htm#ObjectType_Enumerations">NiShaderAttributeDesc::ObjectType</a> eObjType,
<a href="NiStandardMaterial.htm#TexEffectType">TexEffectType</a> eEffectType, unsigned int
uiOccurance,<a href="NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkUVResource)</p>

<p class="NDLRefMemberDescription">This method generates the UV coordinates for a specific texture
effect.</p>

<p class="NDLRefHead2">Mathematics Utility Functions</p>

<p class="NDLRefMemberFunction">virtual bool NormalizeVector(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkVector)</p>

<p class="NDLRefMemberDescription">Normalize the input vector resource. This method will fail if no
fragment exists for this function with the specified input types.</p>

<p class="NDLRefMemberFunction">virtual bool AddVector(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector1, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector2, NiMaterialResource*&amp; pkValue)</p>

<p class="NDLRefMemberDescription">Add the two input vectors together. This method will fail if no
fragment exists for this function with the specified input types.</p>

<p class="NDLRefMemberFunction">virtual bool MultiplyVector(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector1, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector2, NiMaterialResource*&amp; pkValue)</p>

<p class="NDLRefMemberDescription">Multiply the two input vectors together. This method will fail
if no fragment exists for this function with the specified input types.</p>

<p class="NDLRefMemberFunction">virtual bool MultiplyAddVector(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector1, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector2, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector3, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkValue)</p>

<p class="NDLRefMemberDescription">Multiply the first two input vectors together and add the third
input vector to the result. This method will fail if no fragment exists for this function with the
specified input types.</p>

<p class="NDLRefMemberFunction">virtual bool LerpVector(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector1, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector2, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkLerpAmount, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkValue)</p>

<p class="NDLRefMemberDescription">Linearly interpolate the first two input vectors using the third
vector as the percentage for interpolation. This method will fail if no fragment exists for this
function with the specified input types.</p>

<p class="NDLRefMemberFunction">virtual bool ScaleVector(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkScale, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkValue)</p>

<p class="NDLRefMemberDescription">Scale the first input vector by the second input scalar. This
method will fail if no fragment exists for this function with the specified input types.</p>

<p class="NDLRefMemberFunction">virtual bool SaturateVector(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkValue)</p>

<p class="NDLRefMemberDescription">Saturate (clamp to [0.0, 1.0]) the input vector. This method
will fail if no fragment exists for this function with the specified input types.</p>

<p class="NDLRefMemberFunction">virtual bool MultiplyScalarSatAddVector(Context&amp; kContext,
<a href="NiMaterialResource.htm">NiMaterialResource</a>* pkVector1, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkVector2, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkScale, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkValue)</p>

<p class="NDLRefMemberDescription">Implements the following equation: V1.rgb * saturate(V2.rgb +
Scalar.rrr). This method will fail if no fragment exists for this function with the specified input
types.</p>

<p class="NDLRefHead2">Utility Functions</p>

<p class="NDLRefMemberFunction">virtual NiMaterialResource* AddOutputPredefined(<a href=
"NiMaterialNode.htm">NiMaterialNode</a>* pkNode, <a href=
"NiShaderConstantMap.htm#DefinedMappings">NiShaderConstantMap::DefinedMappings</a> eMapping,
unsigned int uiNumRegisters = 1, unsigned int uiCount = 1, unsigned int uiExtraData = 0)</p>

<p class="NDLRefMemberDescription">Add a <a href=
"NiShaderConstantMap.htm">NiShaderConstantMap::DefinedMappings</a> shader constant to the uniforms
for this shade-tree.</p>

<p class="NDLRefMemberFunction">virtual NiMaterialResource* AddOutputObject(<a href=
"NiMaterialNode.htm">NiMaterialNode</a>* pkNode, <a href=
"NiShaderConstantMap.htm">NiShaderConstantMap::ObjectMappings</a> eMapping, <a href=
"NiShaderAttributeDesc.htm#ObjectType_Enumerations">NiShaderAttributeDesc::ObjectType</a>
eObjectType, unsigned int uiObjectCount, const char* pcVariableModifier = NULL, unsigned int
uiCount = 1)</p>

<p class="NDLRefMemberDescription">Add a <a href=
"NiShaderConstantMap.htm">NiShaderConstantMap::ObjectMapping</a>s shader constant to the uniforms
for this shade-tree.</p>

<p class="NDLRefMemberFunction">virtual bool SplitColorAndOpacity(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkColorAndOpacity, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkOpacity)</p>

<p class="NDLRefMemberDescription">This method will split an incoming resource into two output
resources, the RGB color and the opacity scalar.</p>

<p class="NDLRefMemberFunction">virtual bool SplitRGBA(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkColorAndOpacity, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkRed, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkGreen, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkBlue, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkAlpha)</p>

<p class="NDLRefMemberDescription">This method will split an incoming resource into four output
resources, the red, green, blue scalars and the opacity scalar.</p>

<p class="NDLRefMemberFunction">virtual bool TypeCastBind(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkSrc, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkDest)</p>

<p class="NDLRefMemberDescription">Bind one resource to another using any necessary type-casting
functions.</p>

<p class="NDLRefHead2">Texturing Functions</p>

<p class="NDLRefMemberFunction">virtual bool InsertTexture(Context&amp; kContext, <a href=
"NiStandardMaterial.htm#TextureMap">TextureMap</a> eMap, unsigned int uiOccurance, <a href=
"NiStandardMaterial.htm#TextureMapApplyType">TextureMapApplyType</a> eApplyType, <a href=
"NiStandardMaterial.htm#TextureMapSampleType">TextureMapSampleType</a> eSample, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUV, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkInputColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkSampledRGBScalar, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkOutputColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkOutputOpacity)</p>

<p class="NDLRefMemberFunction">virtual bool InsertTexture(Context&amp; kContext, const
NiFixedString&amp; kSamplerName, unsigned int uiOccurance, <a href=
"NiStandardMaterial.htm#TextureMapApplyType">TextureMapApplyType</a> eApplyType, <a href=
"NiStandardMaterial.htm#TextureMapSampleType">TextureMapSampleType</a> eSamplerType, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUV, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkInputColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkSampledRGBScalar, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkOutputColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkOutputOpacity)</p>

<p class="NDLRefMemberDescription">These methods add a texture to the shade-tree. Depending on the
method called, the predefined texture resource specified by name or by enumeration will be added to
the program. This texture will be sampled according to the <a href=
"NiStandardMaterial.htm#TextureMapSampleType">TextureMapSampleType</a>, <span class=
"NDLSystemFont">eSample</span>, and input UV set, <span class="NDLSystemFont">pkUV.</span> The
sampled color has the mathematical operation defined by<span class="NDLSystemFont"><a href=
"NiStandardMaterial.htm#TextureMapApplyType">TextureMapApplyType</a></span> argument, using the
<span class="NDLSystemFont">pkInputColor</span>. The sampled color can optionally be scaled using
the <span class="NDLSystemFont">pkSampledRGBScalar</span> parameter. The final computed RGB color
will be passed by reference using <span class="NDLSystemFont">pkOutputColor</span>. If alpha was
specified, the opacity value will be passed by reference using <span class=
"NDLSystemFont">pkOutputOpacity</span>.</p>

<p class="NDLRefMemberFunction">virtual <a href="NiMaterialResource.htm">NiMaterialResource</a>*
InsertTextureSampler(Context&amp; kContext, const <a href=
"NiFixedString.htm">NiFixedString</a>&amp; kMapName, unsigned int uiOccurance)</p>

<p class="NDLRefMemberDescription">This method inserts the specified texture sampler into the
shade-tree.</p>

<p class="NDLRefMemberFunction">virtual bool HandlePreLightTextureApplication(Context&amp;
kContext, <a href="NiStandardPixelProgramDescriptor.htm">NiStandardPixelProgramDescriptor</a>*
pkPixelDesc, <a href="NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldNormal, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldBinormal, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldTangent, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldViewVector, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkTangentViewVector, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatDiffuseColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatSpecularColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatSpecularPower, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatGlossiness, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatAmbientColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatEmissiveColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkOpacityAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkAmbientLightAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseLightAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkSpecularLightAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseTexAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkSpecularTexAccum, unsigned int&amp;
uiTexturesApplied, <a href="NiMaterialResource.htm">NiMaterialResource</a>** apkUVSets, unsigned
int uiNumStandardUVs, unsigned int uiNumTexEffectUVs)</p>

<p class="NDLRefMemberDescription">This method is the base function for texture application in the
pixel shader.</p>

<p class="NDLRefMemberFunction">virtual bool HandlePostLightTextureApplication(Context&amp;
kContext, <a href="NiStandardPixelProgramDescriptor.htm">NiStandardPixelProgramDescriptor</a>*
pkPixelDesc, <a href="NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldNormal, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkViewVector, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseTexAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkSpecularTexAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkGlossiness, unsigned int&amp; uiTexturesApplied,
<a href="NiMaterialResource.htm">NiMaterialResource</a>** apkUVSets, unsigned int uiNumStandardUVs,
unsigned int uiNumTexEffectUVs)</p>

<p class="NDLRefMemberDescription">This method is called after all lighting has been
accumulated.</p>

<p class="NDLRefMemberFunction">virtual bool HandleParallaxMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkUVSet, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkTangentViewVector)</p>

<p class="NDLRefMemberDescription">This method applies the parallax map fragment. Note that this
material uses a parallax offset of 0.05. The parallax offset is used to determine precisely how
high the parallax mapping effect makes the texture appear. In general, this value should be
computed based off the physical parameters of the surface. Since the height map represents both
positive and negative displacements of the surface in tangent space, we can determine the maximum
degree of those displacements. For example, say that the height field for our texture represents a
displacement of 1 inch either up or down in the sample file. If the span of the texture without
tiling represents 500 inches, then we should set an offset scale of 1/500 or 0.05. This means the
height of a parallax map for this material will always allow for a maximum displacement of 1/500th
of the texture tile size. Ensure that the height values stored in the parallax map are scaled
appropriately.</p>

<p class="NDLRefMemberFunction">virtual bool HandleBaseMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVSet, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseColorAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkOpacity, bool bOpacityOnly)</p>

<p class="NDLRefMemberDescription">This method applies the base map fragment.</p>

<p class="NDLRefMemberFunction">virtual bool HandleNormalMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVSet, NormalMapType eType, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkWorldNormal, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldBinormal, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkWorldTangent)</p>

<p class="NDLRefMemberDescription">This method applies the normal map fragment and returns the new
world normal.</p>

<p class="NDLRefMemberFunction">virtual bool HandleDarkMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVSet, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseColorRes)</p>

<p class="NDLRefMemberDescription">This method handles the dark map fragment.</p>

<p class="NDLRefMemberFunction">virtual bool HandleDetailMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVSet, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseColorRes)</p>

<p class="NDLRefMemberDescription">This method handles the detail map fragment.</p>

<p class="NDLRefMemberFunction">virtual bool HandleGlossMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVSet, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkGlossiness)</p>

<p class="NDLRefMemberDescription">This method handles the gloss map fragment.</p>

<p class="NDLRefMemberFunction">virtual bool HandleBumpMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVSet, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkBumpOffset)</p>

<p class="NDLRefMemberDescription">This method handles the bump map fragment.</p>

<p class="NDLRefMemberFunction">virtual bool HandleGlowMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVSet, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkEmissiveColorRes)</p>

<p class="NDLRefMemberDescription">This method handles the glow map fragment.</p>

<p class="NDLRefMemberFunction">virtual bool HandleCustomMaps(Context&amp; kContext,
NiStandardPixelProgramDescriptor* pkPixDesc, unsigned int&amp; uiWhichTexture, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>** apkUVSets, unsigned int uiNumStandardUVs,
<a href="NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatDiffuseColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatSpecularColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatSpecularPower, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatGlossiness, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatAmbientColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkMatEmissiveColor, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkOpacityAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkAmbientLightAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseLightAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkSpecularLightAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseTexAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkSpecularTexAccum)</p>

<p class="NDLRefMemberDescription">This method is meant for use in derived classes and is the hook
for handling any custom maps.</p>

<p class="NDLRefMemberFunction">virtual bool HandleEnvMap(Context&amp; kContext, <a href=
"NiStandardMaterial.htm#TexEffectType">NiStandardMaterial::TexEffectType</a> eTexEffect, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVResource, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkSpecularAccum, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkBumpOffset, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkGlossiness)</p>

<p class="NDLRefMemberDescription">This method handles applying the correct environment map
fragment.</p>

<p class="NDLRefMemberFunction">virtual bool HandleDecalMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVSet, unsigned int uiIdx, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseColorRes)</p>

<p class="NDLRefMemberDescription">This method applies one of the decal maps.</p>

<p class="NDLRefMemberFunction">virtual bool HandleProjLightMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVSet, unsigned int uiIdx, bool bPerspective,
bool bClipped, <a href="NiMaterialResource.htm">NiMaterialResource</a>* pkWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseAccum)</p>

<p class="NDLRefMemberDescription">This method applies one of the projected lights.</p>

<p class="NDLRefMemberFunction">virtual bool HandleProjShadowMap(Context&amp; kContext, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>* pkUVSet, unsigned int uiIdx, bool bPerspective,
bool bClipped, <a href="NiMaterialResource.htm">NiMaterialResource</a>* pkWorldPos, <a href=
"NiMaterialResource.htm">NiMaterialResource</a>*&amp; pkDiffuseColorRes)</p>

<p class="NDLRefMemberDescription">This method applies one of the projected shadows.</p>

<p class="NDLRefHead1">Protected Supported Static Functions</p>

<p class="NDLRefHead2">Texturing Functions</p>

<p class="NDLRefMemberFunction">static unsigned int FindUVSetIndexForTextureIndex(unsigned int
uiTexture, <a href="NiStandardPixelProgramDescriptor.htm">NiStandardPixelProgramDescriptor</a>*
pkPixDesc)</p>

<p class="NDLRefMemberDescription">Find the UV set array index associated with the <span class=
"NDLSystemFont">uiTexture</span>-th texture in the descriptor.</p>

<p class="NDLRefMemberFunction">static <a href="NiMaterialResource.htm">NiMaterialResource</a>*
FindUVSetIndexForTextureEnum(<a href="NiStandardMaterial.htm#TextureMap">TextureMap</a> eMap,
<a href="NiStandardPixelProgramDescriptor.htm">NiStandardPixelProgramDescriptor</a>* pkPixDesc,
<a href="NiMaterialResource.htm">NiMaterialResource</a>** apkUVSets)</p>

<p class="NDLRefMemberDescription">Find the UV set resource associated with the enumerated texture
in the descriptor.</p>

<p class="NDLRefMemberFunction">static unsigned int FindUVSetIndexForTextureEnum(<a href=
"NiStandardMaterial.htm#TextureMap">TextureMap</a> eMap, <a href=
"NiStandardPixelProgramDescriptor.htm">NiStandardPixelProgramDescriptor</a>* pkPixDesc)</p>

<p class="NDLRefMemberDescription">Find the UV set array index associated with the enumerated
texture in the descriptor.</p>

<p class="NDLRefMemberFunction">static int MapIndexFromTextureEnum(<a href=
"NiStandardMaterial.htm#TextureMap">TextureMap</a> eMap, <a href=
"NiStandardPixelProgramDescriptor.htm">NiStandardPixelProgramDescriptor</a>* pkPixDesc)</p>

<p class="NDLRefMemberDescription">Determine the texture occurrence from the texture enumeration
for this descriptor.</p>

<p class="NDLRefMemberFunction">static bool GetTextureNameFromTextureEnum(<a href=
"NiStandardMaterial.htm#TextureMap">TextureMap</a> eMap, <a href=
"NiFixedString.htm">NiFixedString</a>&amp; kString, unsigned int&amp; uiOccurance)</p>

<p class="NDLRefMemberDescription">Get the name of the texture and its index for that texture name
from the texture enumeration.</p>

<p class="NDLRefMemberFunction">static bool GetTextureTransformMappingFromEnum(<a href=
"NiStandardMaterial.htm#TextureMap">TextureMap</a> eMap, <a href=
"NiShaderConstantMap.htm#DefinedMappings">NiShaderConstantMap::DefinedMappings</a>&amp; eMapping,
unsigned int&amp; uiOccurance)</p>

<p class="NDLRefMemberDescription">Get the texture transform predefined mapping from the texture
enumeration.</p>

<p class="NDLRefMemberFunction">static bool AssignTextureCoordinates(const unsigned int* puiUVSets,
const <a href="NiStandardMaterial.htm#TexGenOutput">TexGenOutput</a>* peTexGenOutputs, const
unsigned int uiTextureCount, <a href=
"NiStandardVertexProgramDescriptor.htm">NiStandardVertexProgramDescriptor</a>* pkVertexDesc,
<a href="NiStandardPixelProgramDescriptor.htm">NiStandardPixelProgramDescriptor</a>*
pkPixelDesc)</p>

<p class="NDLRefMemberDescription">Map the input UV coordinate resources to their associated output
resources after texture transforms have been applied. Make sure that the pixel shader is correctly
accessing the UV coordinate resources.</p>

<p class="NDLRefHead1">Public Supported Static Functions</p>

<p class="NDLRefHead2">Fallback Functions</p>

<p class="NDLRefMemberFunction">static bool SplitPerPixelLights(<a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>* pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#ReturnCode">ReturnCode</a> eFailedRC, unsigned int uiFailedPass, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiMaxCount, unsigned int&amp; uiCount, unsigned int&amp; uiFunctionData)</p>

<p class="NDLRefMemberDescription">Create a new pass for each pass with lighting. The lights are
evenly divided from the original pass into the new passes. Note that this only affects per-pixel
lights. These passes will be additively blended.</p>

<p class="NDLRefMemberFunction">static bool DropShadowMaps(<a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>* pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#ReturnCode">ReturnCode</a> eFailedRC, unsigned int uiFailedPass, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiMaxCount, unsigned int&amp; uiCount, unsigned int&amp; uiFunctionData)</p>

<p class="NDLRefMemberDescription">This technique will remove the shadow maps from the input
passes.</p>

<p class="NDLRefMemberFunction">static bool DropShadowMapsThenSplitPerPixelLights(<a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>* pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#ReturnCode">ReturnCode</a> eFailedRC, unsigned int uiFailedPass, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiMaxCount, unsigned int&amp; uiCount, unsigned int&amp; uiFunctionData)</p>

<p class="NDLRefMemberDescription">This technique is a combination of <span class=
"NDLSystemFont">DropShadowMaps</span> and <span class=
"NDLSystemFont">SplitPerPixelLights</span>.</p>

<p class="NDLRefMemberFunction">static bool SplitPerVertexLights(<a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>* pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#ReturnCode">ReturnCode</a> eFailedRC, unsigned int uiFailedPass, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiMaxCount, unsigned int&amp; uiCount, unsigned int&amp; uiFunctionData)</p>

<p class="NDLRefMemberDescription">Create a new pass for each pass with lighting. The lights are
evenly divided from the original pass into the new passes. Note that this only affects per-vertex
lighting. These passes will be additively blended.</p>

<p class="NDLRefMemberFunction">static bool SplitTextureMaps(<a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>* pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#ReturnCode">ReturnCode</a> eFailedRC, unsigned int uiFailedPass, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiMaxCount, unsigned int&amp; uiCount, unsigned int&amp; uiFunctionData)</p>

<p class="NDLRefMemberDescription">Split texture accesses into two passes. The first pass will
include the standard textures and lighting minus the textures in the second pass. The second pass
will only have the glow, environment, bump, projected lights, and projected shadows with no
lighting. These two passes will be additively blended.</p>

<p class="NDLRefMemberFunction">static bool DropShadowMapsThenSplitTextureMaps(<a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>* pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#ReturnCode">ReturnCode</a> eFailedRC, unsigned int uiFailedPass, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiMaxCount, unsigned int&amp; uiCount, unsigned int&amp; uiFunctionData)</p>

<p class="NDLRefMemberDescription">This technique is a combination of <span class=
"NDLSystemFont">DropShadowMaps</span> and <span class="NDLSystemFont">SplitTextureMaps</span>.</p>

<p class="NDLRefMemberFunction">static bool DropParallaxMap(<a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>* pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#ReturnCode">ReturnCode</a> eFailedRC, unsigned int uiFailedPass, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiMaxCount, unsigned int&amp; uiCount, unsigned int&amp; uiFunctionData)</p>

<p class="NDLRefMemberDescription">This technique will remove the parallax map from the input
passes.</p>

<p class="NDLRefMemberFunction">static bool DropParallaxMapThenSplitLights(<a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>* pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#ReturnCode">ReturnCode</a> eFailedRC, unsigned int uiFailedPass, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiMaxCount, unsigned int&amp; uiCount, unsigned int&amp; uiFunctionData)</p>

<p class="NDLRefMemberDescription">This technique is a combination of <span class=
"NDLSystemFont">DropParallaxMap</span> and <span class=
"NDLSystemFont">SplitPerPixelLights</span>.</p>

<p class="NDLRefMemberFunction">static bool
DropShadowMapsThenDropParallaxMapThenSplitLights(<a href=
"NiMaterialDescriptor.htm">NiMaterialDescriptor</a>* pkMaterialDescriptor, <a href=
"NiFragmentMaterial.htm#ReturnCode">ReturnCode</a> eFailedRC, unsigned int uiFailedPass, <a href=
"NiFragmentMaterial.htm#RenderPassDescriptor">RenderPassDescriptor</a>* pkRenderPasses, unsigned
int uiMaxCount, unsigned int&amp; uiCount, unsigned int&amp; uiFunctionData)</p>

<p class="NDLRefMemberDescription">This technique is a combination of <span class=
"NDLSystemFont">DropShadowMaps</span>, <span class="NDLSystemFont">DropParallaxMap</span>, and
<span class="NDLSystemFont">SplitPerPixelLights</span>..</p>

<p class="NDLRefHead1">Notes</p>

<a name="Transform_Type" id="Transform_Type"></a><p class="NDLRefHead2">Transform Type</p>

<p>This enumeration determines how this material deals with transformations.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">TRANSFORM_DEFAULT</span></td>

            <td>Traditional vertex transformations.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TRANSFORM_SKINNED</span></td>

            <td>Skinned vertex transformations wherein bones are chosen from a palette of
            transforms using per-vertex indices.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TRANSFORM_RESERVED</span></td>

            <td>This value is reserved and should not be used.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TRANSFORM_INSTANCED</span></td>

            <td>Instanced vertex transformations.</td>
        </tr>
    </tbody>
</table>

<a name="NormalType" id="NormalType"></a><p class="NDLRefHead2">Normal Type</p>

<p>This enumeration determines how this material deals with normals.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">NORMAL_NONE</span></td>

            <td>No per-vertex normals.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">NORMAL_ONLY</span></td>

            <td>Per-vertex normals.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">NORMAL_NBT</span></td>

            <td>Per-vertex normal, binormal, and tangent vectors.</td>
        </tr>
    </tbody>
</table>

<a name="Fog" id="Fog"></a><p class="NDLRefHead2">Fog</p>

<p>This enumeration determines how this material deals with fog.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">FOG_NONE</span></td>

            <td>No per-vertex fog.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">FOG_LINEAR</span></td>

            <td>Fog linearly increases based off of camera depth</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">FOG_SQUARED</span></td>

            <td>Fog increases exponentially based off of camera depth.</td>
        </tr>
    </tbody>
</table>

<a name="TexGenInput" id="TexGenInput"></a><p class="NDLRefHead2">TexGenInput</p>

<p>This enumeration determines how this material deals with texture coordinate generation.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">TEX_IN_TEXCOORD</span></td>

            <td>Sourced from an input vertex texture coordinate</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEX_IN_WORLD_POS</span></td>

            <td>Sourced from the world position.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEX_IN_WORLD_NORM</span></td>

            <td>Sourced from the world normal.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEX_IN_WORLD_REFLECT</span></td>

            <td>Sourced from the camera reflection vector in world space.</td>
        </tr>
    </tbody>
</table>

<a name="TexGenOutput" id="TexGenOutput"></a><p class="NDLRefHead2">TexGenOutput</p>

<p>This enumeration determines how this material deals with texture coordinate transformation.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">TEX_OUT_PASSTHRU</span></td>

            <td>Coordinate used as-is.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEX_OUT_TRANSFORM</span></td>

            <td>Coordinate has texture transform applied.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEX_OUT_PARALLEL_PROJECT</span></td>

            <td>Coordinate has parallel projection applied.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEX_OUT_PERSPECTIVE_PROJECT</span></td>

            <td>Coordinate has perspective projection applied.</td>
        </tr>
    </tbody>
</table>

<a name="VertexColorType" id="VertexColorType"></a><p class="NDLRefHead2">VertexColorType</p>

<p>This enumeration determines how this material deals with vertex colors.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">VC_NONE</span></td>

            <td>Material does not have vertex colors.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">VC_EXISTS</span></td>

            <td>Material does have vertex colors.</td>
        </tr>
    </tbody>
</table>

<a name="AmbDiffEmissiveEnum1" id="AmbDiffEmissiveEnum1"></a><p class="NDLRefHead2">AmbDiffEmissiveEnum</p>

<p>This enumeration determines how this material deals with source of ambient/emissive/diffuse
color.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">ADE_IGNORE</span></td>

            <td>Material diffuse, ambient, and emissive come from NiMaterialProperty.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">ADE_EMISSIVE</span></td>

            <td>Material emissive comes from vertex colors. Diffuse and ambient come from
            NiMaterialProperty.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">ADE_AMB_DIFF</span></td>

            <td>Material emissive comes from NiMaterialProperty. Diffuse and ambient come from
            vertex colors.</td>
        </tr>
    </tbody>
</table>

<a name="LightingModeEnum" id="LightingModeEnum"></a><p class="NDLRefHead2">LightingModeEnum</p>

<p>This enumeration determines what lighting model the material uses.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">LIGHTING_E</span></td>

            <td>Only the emissive portion of lighting is used.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">LIGHTING_E_A_D</span></td>

            <td>Lighting uses emissive, ambient, and diffuse portions.</td>
        </tr>
    </tbody>
</table>

<a name="ApplyMode" id="ApplyMode"></a><p class="NDLRefHead2">ApplyMode</p>

<p>This enumeration determines how this material deals with how the material responds to
lighting.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">APPLY_REPLACE</span></td>

            <td>Lighting is ignored.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">APPLY_MODULATE</span></td>

            <td>Lighting is multiplied with texture.</td>
        </tr>
    </tbody>
</table>

<a name="NormalMapType" id="NormalMapType"></a><p class="NDLRefHead2">NormalMapType</p>

<p>This enumeration determines how this material deals with normal maps.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">NORMAL_MAP_STANDARD</span></td>

            <td>Standard RGB normal maps.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">NORMAL_MAP_DXN</span></td>

            <td>ATI's compressed normal map format. (Not implemented)</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">NORMAL_MAP_DXT5</span></td>

            <td>Compressed DXT5 format. R and A are the input vectors. (Not implemented)</td>
        </tr>
    </tbody>
</table>

<a name="LightType" id="LightType"></a><p class="NDLRefHead2">LightType</p>

<p>This enumeration determines how this material deals with lights.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">LIGHT_DIR</span></td>

            <td>Directional light.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">LIGHT_POINT</span></td>

            <td>Point light.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">LIGHT_SPOT</span></td>

            <td>Spot light.</td>
        </tr>
    </tbody>
</table>

<a name="TexEffectType" id="TexEffectType"></a><p class="NDLRefHead2">TexEffectType</p>

<p>This enumeration determines how this material deals with texture effects.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">TEXEFFECT_NONE</span></td>

            <td>No texture effect applied.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXEFFECT_WORLD_PARALLEL</span></td>

            <td>World position multiplied by parallel projection matrix.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXEFFECT_WORLD_PERSPECTIVE</span></td>

            <td>World position multiplied by perspective projection matrix.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXEFFECT_SPHERICAL</span></td>

            <td>Spherical environment map using world reflection as lookup vector.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXEFFECT_DIFFUSE_CUBE</span></td>

            <td>Diffuse cubic environment map using world normal as lookup vector.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXEFFECT_SPECULAR_CUBE</span></td>

            <td>Specular cubic environment map using world refflection as lookup vector..</td>
        </tr>
    </tbody>
</table>

<a name="TextureMap" id="TextureMap"></a><p class="NDLRefHead2">TextureMap</p>

<p>This enumeration determines how this material deals with texture maps.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">MAP_PARALLAX</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Parallax</span></a></td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_BASE</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Base</span></a></td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_NORMAL</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Normal</span></a></td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_DARK</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Dark</span></a></td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_DETAIL</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Detail</span></a></td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_BUMP</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Bump</span></a></td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_GLOSS</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Gloss</span></a></td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_GLOW</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Glow</span></a></td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_CUSTOM00</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Shader</span></a> index 0</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_CUSTOM01</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Shader</span></a> index 1</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_CUSTOM02</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Shader</span></a> index 2</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_CUSTOM03</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Shader</span></a> index 3</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_CUSTOM04</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Shader</span></a> index 4</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_DECAL00</span></td>

            <td><a href="NiTexturingProperty.htm"><span class=
            "NDLSystemFont">NiTexturingProperty::Deca</span>l</a> index 0</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_DECAL01</span></td>

            <td><span class="NDLSystemFont"><a href=
            "NiTexturingProperty.htm">NiTexturingProperty::Decal</a></span> index 1</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_DECAL02</span></td>

            <td><span class="NDLSystemFont"><a href=
            "NiTexturingProperty.htm">NiTexturingProperty::Decal</a></span> index 2</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_PROJECTED_LIGHT00</span></td>

            <td>A projected light texture. ## is a number between 00 and 03.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_PROJECTED_SHADOW00</span></td>

            <td>A projected shadow texture. ## is a number between 00 and 03.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_DIRSHADOW##</span></td>

            <td>Shadow maps from a directional light. ## is a number between 00 and 07.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_POINTSHADOW##</span></td>

            <td>Shadow maps from a point light. ## is a number between 00 and 07.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MAP_SPOTSHADOW##</span></td>

            <td>Shadow maps from a spot light. ## is a number between 00 and 07.</td>
        </tr>
    </tbody>
</table>

<a name="TextureMapSampleType" id="TextureMapSampleType"></a><p class="NDLRefHead2">TextureMapSampleType Enum</p>

<p>This enumeration determines how a texture resource will be sampled for this material.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">TEXTURE_SAMPLE_RGBA</span></td>

            <td>Sample the red, green, blue, and alpha channels of this texture in 2D.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXTURE_SAMPLE_RGB</span></td>

            <td>Sample the red, green, and blue channels of this texture in 2D.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXTURE_SAMPLE_PROJ_RGB</span></td>

            <td>Sample the red, green, and blue channels of this texture using a projected texture
            lookup in 3D.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXTURE_SAMPLE_CUBE_RGB</span></td>

            <td>Sample the red, green, and blue channels of this texture using a cube-map lookup in
            3D.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXTURE_SAMPLE_A</span></td>

            <td>Sample the alpha channel of this texture in 2D.</td>
        </tr>
    </tbody>
</table>

<a name="TextureMapApplyType" id="TextureMapApplyType"></a><p class="NDLRefHead2">TextureMapApplyType Enu</p>

<p>This enumeration determines how a texture resource will be applied for this material.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">TEXTURE_RGB_APPLY_MULTIPLY</span></td>

            <td>Multiply the sampled color by the input color.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXTURE_RGB_APPLY_ADD</span></td>

            <td>Add the sampled color to the input color.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXTURE_RGB_APPLY_LERP</span></td>

            <td>Linearly interpolate between the sampled color and the input color.</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">TEXTURE_RGB_APPLY_NOOP</span></td>

            <td>Pass the input color through.</td>
        </tr>
    </tbody>
</table>

<a name="ControlVariables" id="ControlVariables"></a><p class="NDLRefHead2">Control Enum</p>

<p>This enumeration determines various max values for this material.</p>

<!--(Table)=====================================================================================-->
<table>
    <thead>
        <tr>
            <th>Enumeration</th>

            <th>Meaning</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class="NDLSystemFont">DEFAULT_PIPE_MAX_UVS_FOR_TEXTURES</span></td>

            <td>12</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">DEFAULT_PIPE_MAX_TEXTURE_MAPS</span></td>

            <td>16</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">DEFAULT_PIPE_MAX_DECAL_MAPS</span></td>

            <td>3</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">DEFAULT_PIPE_MAX_LIGHTS</span></td>

            <td>8</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">DEFAULT_PIPE_CUSTOM_MAPS</span></td>

            <td>5</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">MATERIAL_HASH_BUCKET_COUNT</span></td>

            <td>37</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">VERTEX_VERSION</span></td>

            <td><span class="NDLSystemFont">20</span></td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">GEOMETRY_VERSION</span></td>

            <td>0</td>
        </tr>

        <tr>
            <td><span class="NDLSystemFont">PIXEL_VERSION</span></td>

            <td>27</td>
        </tr>
    </tbody>
</table>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

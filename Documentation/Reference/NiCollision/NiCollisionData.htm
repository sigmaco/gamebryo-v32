<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>NiCollisionData</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script> <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>


<p class="NDLRefHeadClassTitle">NiCollisionData</p>

<p class="NDLRefParentage">: public <span><a HREF="../../Reference/NiMain/NiCollisionObject.htm">NiCollisionObject</a></span></p>

<p class="NDLRefHeaderFile">NiCollisionData.h</p>

<p class="NDLRefHead1">Description:</p>

<p>The <span class="NDLSystemFont">NiCollisionData</span> 
 class specifies how collisions are to occur, how propagation of the scene 
 graph should occur, and stores various collision information.</p>

<p class="NDLRefHead1">Constructors:</p>

<p class="NDLRefMemberFunction">NiCollisionData(NiAvObject* 
 pkSceneObject) 
 </p>

<p class="NDLRefMemberDescription">This constructor creates the <span class="NDLSystemFont">NiCollisionData</span> 
 with a collision target pointing to the <span class="NDLSystemFont"><a href="../../Reference/NiMain/NiAVObject.htm">NiAVObject</a></span> 
 passed in.</p>

<p class="NDLRefHead1">Supported Member Functions:</p>

<p class="NDLRefHead2">World Vertex and Normal Functions</p>

<p class="NDLRefMemberFunction">void CreateWorldVertices()</p>

<p class="NDLRefMemberFunction">void UpdateWorldVertices()</p>

<p class="NDLRefMemberFunction">void DestroyWorldVertices()</p>

<p class="NDLRefMemberDescription">Create, update, and destroy an array of 
 vertices in world space.&nbsp; World-space vertices are not normally stored 
 explicitly, but some systems do need them.&nbsp; These functions enable 
 those systems to keep track of world-space vertices, as needed.&nbsp; 
 Note that the list of world-space vertices will not be updated to reflect 
 a change in the model-space vertices, unless the <span class="NDLSystemFont">UpdateWorldVertices</span> call is made.</p>

<p class="NDLRefMemberFunction">NiPoint3* GetWorldVertices() 
 const</p>

<p class="NDLRefMemberDescription">Returns a pointer to the list of world-space 
 vertices.&nbsp; Note that this list will not exist unless the <span class="NDLSystemFont"><a href="../../Reference/NiMesh/NiMesh.htm">NiMesh</a> 
 </span>object has been specifically told by a <span class="NDLSystemFont">CreateWorldVertices</span> 
 call to create it. Additionally, a call to <span class="NDLSystemFont">UpdateWorldVertices</span> 
 should also be made to ensure that the vertex array is initialized correctly.</p>

<p class="NDLRefMemberFunction">void CreateWorldNormals()</p>

<p class="NDLRefMemberFunction">void UpdateWorldNormals()</p>

<p class="NDLRefMemberFunction">void DestroyWorldNormals()</p>

<p class="NDLRefMemberDescription">Create, update, and destroy an array of 
 normals in world space.&nbsp; World-space normals are not normally stored 
 explicitly, but some systems do need them.&nbsp; These functions allow 
 those systems to keep track of world-space normals as needed.&nbsp; Note 
 that the list of world-space normals will not be updated to reflect a 
 change in the model-space normals unless the <span class="NDLSystemFont">UpdateWorldNormals</span> call is made.</p>

<p class="NDLRefMemberFunction">const 
 NiPoint3* GetWorldNormals() 
 const</p>

<p class="NDLRefMemberDescription">Returns a pointer to the list of world-space 
 normals.&nbsp; Note that this list will not exists unless the <span class="NDLSystemFont"><a href="../../Reference/NiMesh/NiMesh.htm">NiMesh</a></span> 
 object has been specifically told by a <span class="NDLSystemFont">CreateWorldNormals</span> 
 call to create it.</p>

<p class="NDLRefMemberFunction">unsigned short GetTriangleCount()</p>

<p class="NDLRefMemberDescription">Returns the triangle count stored. </p>

<p class="NDLRefMemberFunction">bool 
 GetWorldTriangle(unsigned 
 short usTriangle, 
 NiPoint3*&amp;&nbsp;pkP0, NiPoint3*&amp; pkP1, NiPoint3*&amp; pkP2)</p>

<p class="NDLRefMemberDescription">Returns the world coordinates of triangle 
 number <span class="NDLSystemFont">usTriangle</span>.&nbsp; 
 The application has the responsibility for ensuring that the triangle 
 index is within range.&nbsp; Moreover, it is possible that the world vertex 
 array does not yet exist.&nbsp; To guarantee the necessary data structures, 
 <span class="NDLSystemFont">CreateWorldVertices</span> and <span class="NDLSystemFont">UpdateWorldVertices</span> should be called first. <span class="NDLSystemFont">GetWorldTriangle</span> will fail and return false if the world vertex array does not exist or 
 if there are degenerate indices referencing the vertex array.</p>

<p class="NDLRefHead2">Collision Functions</p>

<p class="NDLRefMemberFunction">NiCollisionGroup::Callback 
 GetCollideCallback();</p>

<p class="NDLRefMemberFunction">void SetCollideCallback(NiCollisionGroup::Callback 
 pfnCollideCallback)</p>

<p class="NDLRefMemberDescription">Retrieve and set the collision callback 
 user data object.&nbsp; This pointer is passed to the object's collision 
 callback whenever it is called.&nbsp; This pointer is treated as opaque 
 by the object, and the object will not delete it at the time of object 
 destruction.</p>

<p class="NDLRefMemberFunction">void* 
 GetCollideCallbackData()</p>

<p class="NDLRefMemberFunction">void SetCollideCallbackData(void* 
 pvCollideCallbackData)</p>

<p class="NDLRefMemberDescription">Retrieve and set the collision callback 
 user data object.&nbsp; This pointer is passed to the object's collision 
 callback whenever it is called.&nbsp; This pointer is treated as opaque 
 by the object, and the object will not delete it at the time of object 
 destruction.</p>

<p class="NDLRefMemberFunction">void SetEnableAuxCallbacks(bool 
 bEnable) bool GetEnableAuxCallbacks()</p>

<p class="NDLRefMemberDescription">By default, auxiliary callbacks are turned 
 off. Auxiliary callbacks will enable your application to receive call 
 backs for intersecting objects that are specified with the propagation 
 flag <span class="NDLSystemFont">PROPAGATE_ON_SUCCESS</span>. Normally, 
 callbacks only occur between objects using the propagation types <span 
 class="NDLSystemFont">PROPAGATE_ALWAYS</span> or <span class="NDLSystemFont">PROPAGATE_NEVER</span>. 
 This is so because usually such types indicate a non-object culling type 
 collision.</p>

<p class="NDLRefMemberFunction">void SetPropagationMode(PropagationMode ePropagation)</p>

<p class="NDLRefMemberFunction">PropagationMode GetPropagationMode() const</p>

<p class="NDLRefMemberDescription"><span class="NDLSystemFont">SetPropagateMode</span> 
 accepts a class-scoped enumerated type <span class="NDLSystemFont">PropagationMode</span> 
 parameter. The propagation mode controls scene graph traversal during 
 collision detection operations. Valid values for the <span class="NDLSystemFont">PropagationMode</span> 
 are:</p>

<ul>
	
	<li><span 
 class="NDLSystemFont">PROPAGATE_NEVER</span><br>
	Propagation never occurs regardless of collision result. Callbacks 
 are made with objects using this propagation setting. </li>
	
	<li><span 
 class="NDLSystemFont">PROPAGATE_ON_SUCCESS</span><br>
	Propagation only occurs as a result of a successful collision. Callbacks 
 are not made with objects of this type unless the auxiliary callback flag 
 is enabled.</li>
	
	<li><span 
 class="NDLSystemFont">PROPAGATE_ALWAYS</span><br>
	Propagation always occurs regardless of collision result. Callbacks 
 are made with objects using this propagation setting.</li>
</ul>

<p class="NDLRefMemberDescription">(The PROPAGATE_ON_FAILURE flag has almost never 
 been used by customers and has been deprecated. It indicated that the 
 propagation down the scene graph should only occur upon a failure of collision 
 detection.)</p>

<p class="NDLRefMemberDescription">For more information, see the section on <a href="Propagation_Control_Flags.htm">propagation control 
 flags</a>.</p>

<p class="NDLRefMemberFunction">void SetCollisionMode(CollisionMode eCollision)</p>

<p class="NDLRefMemberFunction">CollisionMode GetCollisionMode() const</p>

<p class="NDLRefMemberDescription"><span class="NDLSystemFont">SetCollisionMode</span> 
 accepts a class-scoped enumerated type <span class="NDLSystemFont">CollisionMode</span> 
 parameter. The collision mode controls the type of collision operation 
 that is to take place. Valid values for the <span class="NDLSystemFont">CollisionMode</span> 
 are:</p>

<ul>
	
	<li><span 
 class="NDLSystemFont">NOTEST</span><br>
	This flag indicates that no collision test should be made.</li>
	
	<li><span 
 class="NDLSystemFont">USE_ABV</span><br>
	This flag indicates that a user supplied <a href="Alternate_Bounding_Volumes.htm">Alternate 
 Bounding Volume</a> is to be used for collision detection.</li>
	
	<li><span 
 class="NDLSystemFont">USE_NIBOUND</span><br>
	This flag indicates that the <span class="NDLSystemFont"><a href="../../Reference/NiMain/NiBound.htm">NiBound</a></span> 
 of the <span class="NDLSystemFont"><a href="../../Reference/NiMain/NiAVObject.htm">NiAVObject</a></span>, 
 to which the collision data is attached, should be used for collision 
 detection.</li>
	
	<li><span 
 class="NDLSystemFont">USE_OBB</span><br>
	This flag indicates that <a href="Oriented_Bounding_Boxes.htm">Oriented 
 Bounding Boxes</a> are to be created and used for more efficient triangle 
 collision testing.</li>
	
	<li><span 
 class="NDLSystemFont">USE_TRI</span><br>
	This flag indicates that raw <a href="Triangles.htm">Triangle</a> 
 collision testing is to be used.</li>
</ul>

<p class="NDLRefMemberDescription">For more information, see the section 
 on <a href="Collision_Control_Flags.htm">collision 
 control flags</a>.</p>

<p class="NDLRefMemberFunction">NiBoundingVolume* GetModelSpaceABV() const</p>

<p class="NDLRefMemberFunction">void SetModelSpaceABV(NiBoundingVolume* pkABV)</p>

<p class="NDLRefMemberDescription">These 
 functions give access to the model space alternate bounding volume for 
 the object. The <span class="NDLSystemFont"><a href="../../Reference/NiMain/NiAVObject.htm">NiAVObject</a></span> object assumes ownership of the input bounding volume.&nbsp; Therefore 
 the application must dynamically allocate the bounding volume and not 
 attempt to delete it explicitly at a later time.&nbsp; Calling this function 
 also causes the world space bounding volume to be generated.&nbsp; <a href="Alternate_Bounding_Volumes.htm">Alternate Bounding 
 Volumes</a> are discussed in more detail in the Gamebryo <a href="Introduction_to_Collision.htm">Introduction 
 to Collision</a> document.</p>

<p class="NDLRefMemberFunction">NiBoundingVolume* GetWorldSpaceABV() const</p>

<p class="NDLRefMemberDescription">This 
 function returns a pointer to the world space alternate bounding volume 
 for the current instance, or <span class="NDLSystemFont">NULL</span> if an alternate bounding has not been set.</p>

<p class="NDLRefMemberFunction">const NiPoint3&amp; GetLocalVelocity() const 
 </p>

<p class="NDLRefMemberFunction">void SetLocalVelocity(const NiPoint3&amp; 
 kLocalVelocity)</p>

<p class="NDLRefMemberDescription">Retrieve and set the model-space velocity 
 vector of the object.&nbsp; This vector specifies the velocity of the 
 object and is used during dynamic collision detection to predict collisions. 
 </p>

<p class="NDLRefMemberFunction">Const NiPoint3&amp; GetWorldVelocity() const</p>

<p class="NDLRefMemberDescription">Retrieves the world-space version of the 
 object's local velocity vector.</p>

<p class="NDLRefMemberFunction">void SetWorldVelocity(const 
 NiPoint3&amp; kWorldVelocity)</p>

<p class="NDLRefMemberDescription">This function allows the application programmer 
 to set velocity directly. Note, however that this function should only 
 be used when the static function <span class="NDLSystemFont">SetEnableVelocity</span> 
 is passed a <span class="NDLSystemFont">false</span> value. This ensures 
 that the world velocity is not overwritten by the collision system.</p>

<p class="NDLRefMemberFunction">static bool GetEnableVelocity()</p>

<p class="NDLRefMemberFunction">static void SetEnableVelocity(bool bEnable)</p>

<p class="NDLRefMemberDescription">Retrieve and set whether the world velocity 
 is computed in <span class="NDLSystemFont">UpdateWorldData</span>. The default 
 is to NOT compute object world velocity. <span class="NDLSystemFont">NiCollisionData::SetEnableVelocity(true)</span> 
 must be called once, at application initialization time, to allow world 
 velocity to be computed.</p>

<p class="NDLRefMemberFunction">static bool ValidateForCollision(NiAVObject* 
 pkObj, CollisionMode eMode)</p>

<p class="NDLRefMemberDescription">This function returns true if and only 
 if the provided <span class="NDLSystemFont">NiAVObject</span> is a valid 
 object to use in a collision test of type <span class="NDLSystemFont">eMode</span>.</p>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

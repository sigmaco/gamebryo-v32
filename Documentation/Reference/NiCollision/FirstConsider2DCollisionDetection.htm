<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>First, Consider 2D Collision Detection</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script> <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>


<h1>First, Consider 2D Collision Detection</h1>

<p>Consider using a 2D collision detection approach, if feasible.</p>

<p>For example, assume your application has the following
 requirements:</p>
<ul>
	
	<li>Your project has a lot of
	objects with which characters may collide.</li>

    <li>There are only a few
	characters that will collide against these objects.</li>

    <li>Your goals are minimal CPU
	usage and use of a minimal amount of memory per object.</li>
</ul>

<p>Then the best way to determine collision results against
 these objects may be to use a 2D collision detection approach.</p>
 
<p>The basic approach is to use a character-to-floor picking
 approach against simple 2D bounding polygons (one for each model), and then
 to extend it to do a viable collision response.  Picking is almost always
 faster than fully general 3D black-box collision detection.</p>

<p>A 2D top-down view of the level acts as the blue print.
 Boxes map to rectangles, for example.  If a character is moving about the
 level, a capsule bounding volume projects to a circle.  Intersection between
 character and wall in 3D could then be handled in the 2D projection as a
 number of vertical picks to figure out if the character or camera is in
 &quot;a valid place&quot; or not.</p>
 
<p>(Alternatively, such an intersection could be handled in
 the 2D projection as an intersection between circle and line segment.)</p>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>NiPhysXScene</title>
<!--(Begin Meta)================================================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Expedition" />
<meta name="Generator" content="DoxyConvert by Emergent Game Technologies - http://emergent.net" />

<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)==================================================================================-->
    
<!--(Begin Links)===============================================================================-->

<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=================================================================================-->

</head>
  
<!--(Body)======================================================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<p class="NDLRefHeadClassTitle">NiPhysXScene</p>
<p class="NDLRefParentage">: public <span class="NDLSystemFont"><a href="../NiMain/NiObjectNET.htm">NiObjectNET</a></span></p>


<p class="NDLRefHeaderFile">&lt;NiPhysXScene.h&gt;</p>

<p class="NDLRefHead1" style="text-align: center; ">
<div class="FigureContainer">
  <img src="./images/class_ni_phys_x_scene.gif" alt="Inheritance graph for NiPhysXScene"/>
  <p class="FigureCaption">Inheritance graph for NiPhysXScene</p>
</div>
</p>

<p class="NDLRefHead1">Description</p>
<p class="NDLNormal">Each <span class="NDLSystemFont">NiPhysXScene</span> object manages a NxScene object and the Gamebryo objects that interact with it. </p>

<a name="public_methods"></a>
<p class="NDLRefHead1">Public Methods</p>


<a name="class_ni_phys_x_scene_1aa315c71dc9f483437de3fa426bd3c8f9"></a>
<p class="NDLRefMemberFunction">NiPhysXScene(<span class="NDLSystemFont"><a href="../NiFloodgate/NiSPWorkflowManager.htm">NiSPWorkflowManager</a></span>* pkWorkflowManager = 0)</p>
<p class="NDLRefMemberDescription">Constructor. </p>
<p class="NDLRefMemberDetailedDescription">The optional workflow manager argument is used by mesh modifiers associated with the scene. A locally owned workflow manager is created if one is not given here. </p>

<a name="class_ni_phys_x_scene_1a95826be2024fafa42c49a87fce015402"></a>
<p class="NDLRefMemberFunction">~NiPhysXScene()</p>
<p class="NDLRefMemberDescription">Destructor. </p>
<p class="NDLRefMemberDetailedDescription">In addition to freeing all data associated with the scene, this function also removes from the NxScene object any contents associated with this scene. </p>
<a name="debug_rendering"></a>
<p class="NDLRefHead1">Debug Rendering</p>

<p class="NDLRefMemberDescription">If enabled, Gamebryo draws any debug rendering output produced by PhysX for this scene.</p>
<p class="NDLRefMemberDescription">You must separately enable debug visualization in PhysX via the SDK parameter NX_VISUALIZATION_SCALE and individual parameters for each form of debug output. Note that debug geometry is not produced until FetchResults returns true, so do not expect output immediately. </p>

<a name="class_ni_phys_x_scene_1a9f100650d96f82892acca8babda03f24"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  GetDebugRender() const</p>
<p class="NDLRefMemberDescription">Returns true if debug rendering is active. </p>

<a name="class_ni_phys_x_scene_1a67fcf612e44057969d68c4cd783bf8e3"></a>
<p class="NDLRefMemberFunction">void  SetDebugRender(<br/>const <span class="NDLSystemFont">bool</span> bActive, <br/><span class="NDLSystemFont"><a href="../NiMain/NiNode.htm">NiNode</a></span>* pkDebugParent = 0)</p>
<p class="NDLRefMemberDescription">Set the debug rendering flag. </p>
<p class="NDLRefMemberDetailedDescription">If bActive is true, the pkDebugParent argument must be a scene graph node to which the debug geometry can be attached as a child. It does not really matter which node (provided it is updated and rendered) because coordinate systems are correctly accounted for by the debug rendering.</p>
<p class="NDLRefMemberDetailedDescription">Default is false. </p>

<a name="class_ni_phys_x_scene_1ac68a860261b83bea3ee173baed47cb48"></a>
<p class="NDLRefMemberFunction">void  ClearDebugGeometry()</p>
<p class="NDLRefMemberDescription">Deletes any Gamebryo nodes representing debug geometry. </p>
<p class="NDLRefMemberDetailedDescription">Use this when simulation has stopped but the debug flag remains set, or when the simulation is reset. Note that debug geometry is not updated until FetchResults returns true, so in some cases this function can be used to prevent the rendering of inaccurate debug geometry from a previous time step. </p>
<a name="mesh_modifier_functionality"></a>
<p class="NDLRefHead1">Mesh Modifier Functionality</p>

<p class="NDLRefMemberDescription">The <span class="NDLSystemFont">NiPhysXScene</span> class holds an array of objects, derived from <span class="NDLSystemFont"><a href="../NiMesh/NiMesh.htm">NiMesh</a></span>, that need to have mesh modifiers submitted or completed when a simulation step begins or ends.</p>
<p class="NDLRefMemberDescription">Each of the meshes in the array has <span class="NDLSystemFont"><a href="../NiMesh/NiMesh.htm#class_ni_mesh_1a70c2f38c346feca509e91aeb5a6cd6d4">NiMesh::CompleteModifiers</a></span> and <span class="NDLSystemFont"><a href="../NiMesh/NiMesh.htm#class_ni_mesh_1a2ba9d587eeef037f9fbcebbb20166068">NiMesh::SubmitModifiers</a></span> called on it immediately before NxScene::simulate is called (with SyncPoint SYNC_PHYSICS_SIMULATE) and immediately after NxScene::fetchResults succeeds (with SyncPoint SYNC_PHYSICS_COMPLETED).</p>
<p class="NDLRefMemberDescription">Modified meshes that are held by a <span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span> object will be automatically added and removed when the prop is added and removed from the scene. Applications should only use the functionality here if they are creating PhysX content outside of the prop system. </p>

<a name="class_ni_phys_x_scene_1ac84baaacafcea3dc97aed395a575482c"></a>
<p class="NDLRefMemberFunction">void  AddModifiedMesh(<span class="NDLSystemFont"><a href="../NiMesh/NiMesh.htm">NiMesh</a></span>* pkMesh)</p>
<p class="NDLRefMemberDescription">Add a mesh to the set that requires modifier notification. </p>

<a name="class_ni_phys_x_scene_1abe3779a453bcef20421b361e53fe9c0b"></a>
<p class="NDLRefMemberFunction">void  DeleteModifiedMesh(<span class="NDLSystemFont"><a href="../NiMesh/NiMesh.htm">NiMesh</a></span>* pkMesh)</p>
<p class="NDLRefMemberDescription">Remove a mesh from the set that requires modifier notification. </p>

<a name="class_ni_phys_x_scene_1a4a643e5f274b4931414570794bcd19c3"></a>
<p class="NDLRefMemberFunction">void  NotifyAllSceneChanged()</p>
<p class="NDLRefMemberDescription">Notify modified meshes that something about the scene has changed. </p>
<p class="NDLRefMemberDetailedDescription">This function causes the SceneChanged function to be called on all mesh modifiers derived from <span class="NDLSystemFont"><a href="NiPhysXMeshModifier.htm">NiPhysXMeshModifier</a></span> and associated with meshes in the modified mesh array. This function is called whenever any of the following are called on this scene: SetPhysXScene, SetSceneXform, SetScaleFactor, SetAsynchronousSimulation, SetUpdateSrc and SetUpdateDest.</p>
<p class="NDLRefMemberDetailedDescription">In cases where correct setup of the modifier depends on both being attached to the mesh and associated with a PhysX scene, applications may need to call this function, or NotifySceneChanged, when NiPhysXMeshModifier-derived modifiers are attached to a mesh that is already associated with a scene. For example, when <span class="NDLSystemFont"><a href="../NiMesh/NiMesh.htm#class_ni_mesh_1ab4b9a50fa93e9a2007cb7b44f8e1f103">NiMesh::AttachModifier</a></span> is called, or NiMesh::ResetModifier is called, or any other function that causes a modifier to have the <span class="NDLSystemFont"><a href="../NiMesh/NiMeshModifier.htm#class_ni_mesh_modifier_1af5e21fe19ab94611afdc4142ea538afa">NiMeshModifier::Attach</a></span> or <span class="NDLSystemFont"><a href="../NiMesh/NiMeshModifier.htm#class_ni_mesh_modifier_1ad5bba2b2ccf58a17c12b1dab0078cc4e">NiMeshModifier::Detach</a></span> function called. </p>

<a name="class_ni_phys_x_scene_1a01d772ea78dee4d791350e51945b26bc"></a>
<p class="NDLRefMemberFunction">void  NotifySceneChanged(<br/><span class="NDLSystemFont"><a href="../NiMesh/NiMesh.htm">NiMesh</a></span>* pkMesh, <br/><span class="NDLSystemFont">bool</span> bRemoving = false)</p>
<p class="NDLRefMemberDescription">Notify a mesh that something about the scene has changed. </p>
<p class="NDLRefMemberDetailedDescription">This function causes the SceneChanged function to be called on all mesh modifiers derived from <span class="NDLSystemFont"><a href="NiPhysXMeshModifier.htm">NiPhysXMeshModifier</a></span> and associated with the given mesh. This function is called by NotifyAllSceneChanged and when the mesh is first associated with the scene and when it is removed from the scene. The bRemoving argument is true only when the mesh has been removed from the scene.</p>
<p class="NDLRefMemberDetailedDescription">In cases where correct setup of the modifier depends on both being attached to the mesh and associated with a PhysX scene, applications may need to call this function, or NotifyAllSceneChanged, when NiPhysXMeshModifier-derived modifiers are attached to a mesh that is already associated with a scene. For example, when <span class="NDLSystemFont"><a href="../NiMesh/NiMesh.htm#class_ni_mesh_1ab4b9a50fa93e9a2007cb7b44f8e1f103">NiMesh::AttachModifier</a></span> is called, or <span class="NDLSystemFont"><a href="../NiMesh/NiMesh.htm#class_ni_mesh_1a3b894ce3ab088d8807a4e641f255b74a">NiMesh::ResetModifiers</a></span> is called. </p>
<a name="nxscene_management"></a>
<p class="NDLRefHead1">NxScene Management</p>

<p class="NDLRefMemberDescription">There are two ways to set the NxScene object for this scene.</p>
<p class="NDLRefMemberDescription">The SetPhysXScene function should be used when an application has already created the PhysX scene, and it is best called before any props are added to the scene. Otherwise, the application must explicitly iterate over the existing props and instantiate them in the scene. The alternative is to create a snapshot for this scene, and use CreateSceneFromSnapshot which automatically instantiates any props in the scene. </p>

<a name="class_ni_phys_x_scene_1aceb011a1fbcbb3c7d4e4c78cdc6a4942"></a>
<p class="NDLRefMemberFunction">NxScene*  GetPhysXScene() const</p>
<p class="NDLRefMemberDescription">Get the NxScene that is associated with this scene. </p>

<a name="class_ni_phys_x_scene_1a241a3eb7be420d916c542e5e4e79c629"></a>
<p class="NDLRefMemberFunction">void  SetPhysXScene(NxScene* pkScene)</p>
<p class="NDLRefMemberDescription">Set the NxScene that is associated with this scene. </p>
<p class="NDLRefMemberDetailedDescription">In almost all circumstances applications must call this function before attempting simulation - the only exception is if you instead create a snapshot and use CreateSceneFromSnapshot. This function only stores the pointer; props that are already attached to this object are NOT created in the PhysX scene. Use the snapshot in each prop to explicitly create the props.</p>
<p class="NDLRefMemberDetailedDescription">Note that the <span class="NDLSystemFont"><a href="../efdPhysX/efdPhysX__PhysXSDKManager.htm#classefd_phys_x_1_1_phys_x_s_d_k_manager_1a0a7b7859f04b978fb0875dbe4ff15efd">efdPhysX::PhysXSDKManager::CreateSceneOnDifferentCore</a></span> function is available to help with the creation of NxScene objects that execute on a specific core. This is particularly important on the Xenon platform, where by default the PhysX scene runs on the same core as the application main thread.</p>
<p class="NDLRefMemberDetailedDescription">It is an error to set the scene when a scene has already been set. Release the old scene first. </p>

<a name="class_ni_phys_x_scene_1a1db3bb306f3632426cde4ff30b39dd39"></a>
<p class="NDLRefMemberFunction">void  ReleaseScene()</p>
<p class="NDLRefMemberDescription">Release the NxScene associated with this scene. </p>
<p class="NDLRefMemberDetailedDescription">This first removes all props from the scene (to clear pointers into the NxScene object) then releases the PhysX scene from the SDK. </p>

<a name="class_ni_phys_x_scene_1a73b2ef871e1c7522dc568b17f5344a36"></a>
<p class="NDLRefMemberFunction">NxCompartment*  GetCompartmentAt(<span class="NDLSystemFont">NiUInt32</span> uiID)</p>
<p class="NDLRefMemberDescription">Get the simulation compartment that was registered with the given ID. </p>

<a name="class_ni_phys_x_scene_1a5fec842f8e7c7037d882eba92c54fa6d"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  AddCompartment(<br/><span class="NDLSystemFont">NiUInt32</span> uiID, <br/>NxCompartment* pkCompartment)</p>
<p class="NDLRefMemberDescription">Add a compartment using an existing pointer. </p>
<p class="NDLRefMemberDetailedDescription">The compartment IDs are used by props to determine which compartment to instantiate their contents in. </p>

<a name="class_ni_phys_x_scene_1afd483c21f8b928bde9acc11bd6c9f51b"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  AddCompartment(<br/><span class="NDLSystemFont">NiUInt32</span> uiID, <br/>NxCompartmentDesc& pkDescriptor)</p>
<p class="NDLRefMemberDescription">Add a compartment using a descriptor. </p>
<p class="NDLRefMemberDetailedDescription">This causes a new compartment to be created in the target scene, which must have been specified at the time this function is called. The compartment IDs are used by props to determine which compartment to instantiate their contents in. </p>
<a name="physx_coordinate_system"></a>
<p class="NDLRefHead1">PhysX Coordinate System</p>

<p class="NDLRefMemberDescription">The PhysX global coordinate system may not coincide with the Gamebryo global coordinate system, so a transformation is stored that relates the two.</p>
<p class="NDLRefMemberDescription">It is the transform to apply to PhysX state to place it in Gamebryo's coordinates. In addition, there is a scale factor which is applied to all state. It is a convenience so that applications do not need to manage scaling themselves. The scale factor on the scene should match the scale factor on all of the props attached to the scene, or ill-defined behavior will result. </p>

<a name="class_ni_phys_x_scene_1ae87e22bd4600ad6b2bf4f55d0cc82110"></a>
<p class="NDLRefMemberFunction">const <span class="NDLSystemFont"><a href="../NiMain/NiTransform.htm">NiTransform</a></span>&  GetSceneXform() const</p>
<p class="NDLRefMemberDescription">Get the PhysX to Gamebryo relative transformation. </p>

<a name="class_ni_phys_x_scene_1abd5a72cfdfcf62b5478cb4551a9b460c"></a>
<p class="NDLRefMemberFunction">void  SetSceneXform(const <span class="NDLSystemFont"><a href="../NiMain/NiTransform.htm">NiTransform</a></span>& kXform)</p>
<p class="NDLRefMemberDescription">Set the PhysX to Gamebryo relative transformation. Default is identity. </p>

<a name="class_ni_phys_x_scene_1a052bbb8dda5da3bf096e1bff5d111b91"></a>
<p class="NDLRefMemberFunction">float  GetScaleFactor() const</p>
<p class="NDLRefMemberDescription">Get the scale. </p>
<p class="NDLRefMemberDetailedDescription">Gamebryo world size is fScale times physics size. </p>

<a name="class_ni_phys_x_scene_1ae53bea384a61a8382639110de6dc6fbe"></a>
<p class="NDLRefMemberFunction">void  SetScaleFactor(const float fScale)</p>
<p class="NDLRefMemberDescription">Set the scale. </p>
<p class="NDLRefMemberDetailedDescription">Gamebryo world size is fScale times physics size. Default is 1.0. </p>
<a name="prop_management"></a>
<p class="NDLRefHead1">Prop Management</p>

<p class="NDLRefMemberDescription">A <span class="NDLSystemFont">NiPhysXScene</span> object stores an array of smart pointers to props, and all simulation and update operations on the scene affect all of the props.</p>
<p class="NDLRefMemberDescription">Think of the scene as the container that holds the props and causes them to interact with each other. Props in different scenes will not interact with those in this one. </p>

<a name="class_ni_phys_x_scene_1a251d6399d58c4b927e47dc0e3c817c20"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">NiUInt32</span>  GetPropCount() const</p>
<p class="NDLRefMemberDescription">Return the number of props this scene holds. </p>
<p class="NDLRefMemberDetailedDescription">The array is packed, so the value returned is the actual number of props. </p>

<a name="class_ni_phys_x_scene_1af62ac8d9884c4cc3976ddf08532332e2"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">NiUInt32</span>  AddProp(<br/><span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span>* pkProp, <br/><span class="NDLSystemFont">NiUInt32</span> uiState = 0)</p>
<p class="NDLRefMemberDescription">Add a prop to the scene. </p>
<p class="NDLRefMemberDetailedDescription">The prop's PhysX content is also instantiated in the NxScene object if that has already been specified or created. The uiState argument specifies which cached snapshot state to use when the prop is instantiated. The return value is the index in the internal array of props at which this prop was added, or (unsigned int)-1 if there was an error instantiating the PhysX contents of the prop. </p>

<a name="class_ni_phys_x_scene_1a41eb6a2e0da91d2894ca0c1f2f198e85"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span>*  GetPropAt(const <span class="NDLSystemFont">NiUInt32</span> uiIndex)</p>
<p class="NDLRefMemberDescription">Retrieve the prop stored at the given index. </p>

<a name="class_ni_phys_x_scene_1a8046871e86afd54d668753761cfe6740"></a>
<p class="NDLRefMemberFunction">void  RemoveProp(<span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span>* pkTarget)</p>
<p class="NDLRefMemberDescription">Remove the specified prop. </p>
<p class="NDLRefMemberDetailedDescription">The prop's PhysX content is removed from the NxScene object if that has already been specified or created and the prop has a snapshot to tell us which PhysX content belongs to the prop. </p>

<a name="class_ni_phys_x_scene_1aaaaaf73e4cadc7c141091e806864a85b"></a>
<p class="NDLRefMemberFunction">void  RemovePropAt(const <span class="NDLSystemFont">NiUInt32</span> uiIndex)</p>
<p class="NDLRefMemberDescription">Remove the prop at the specified index. </p>
<p class="NDLRefMemberDetailedDescription">The prop's PhysX content is removed from the NxScene object if that has already been specified or created and the prop has a snapshot to tell us which PhysX content belongs to the prop. </p>
<a name="simulation_functions"></a>
<p class="NDLRefHead1">Simulation Functions</p>

<p class="NDLRefMemberDescription"><span class="NDLSystemFont">NiPhysXScene</span> objects provide the interface to NxScene::simulate() and NxScene::fetchResults() calls.</p>
<p class="NDLRefMemberDescription">Applications must always work through these functions to maintain a consistent simulation state. These functions enforce various rules related to simulation, such as making certain that simulate and fetchResults are always interleaved.</p>
<p class="NDLRefMemberDescription">The <span class="NDLSystemFont">NiPhysXScene</span> object takes complete control over the timing of the physics scene. Applications should not make any calls to NxScene::setTiming - they will be over-ridden by this object.</p>
<p class="NDLRefMemberDescription">Some of these functions control the time step that Gamebryo uses when calling simulate() for this scene and the time steps that PhysX uses. If active, fixed stepping uses a multiple of the given time step (set through SetTimestep) sufficient to get to or surpass the requested update time, otherwise it uses the difference between the target time and the most recent time (which depends on how the application calls update). The PhysX scene is set to use the same stepping mechanism, fixed or variable, as this object. The max time step passed to NxScene::setTiming is controlled by SetNumSubSteps: maxTimestep = fStep / uiNumSteps. The argument to SetMaxNumSteps is the same as would be passed as the maxIter argument to NxScene::setTiming. </p>

<a name="class_ni_phys_x_scene_1a25401533e62e3d2258871d63eedfcf5e"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  GetDoFixedStep() const</p>
<p class="NDLRefMemberDescription">Get the flag controlling fixed or variable simulation timing. </p>

<a name="class_ni_phys_x_scene_1aa827829e0942c62f6bf200d85cafb752"></a>
<p class="NDLRefMemberFunction">void  SetDoFixedStep(const <span class="NDLSystemFont">bool</span> bActive)</p>
<p class="NDLRefMemberDescription">Set the flag controlling fixed or variable simulation timing. </p>
<p class="NDLRefMemberDetailedDescription">Default is true. </p>

<a name="class_ni_phys_x_scene_1ab5970c1e2ad69625dff5da95aa3cc88d"></a>
<p class="NDLRefMemberFunction">float  GetTimestep() const</p>
<p class="NDLRefMemberDescription">Get the timestep that Gamebryo uses with fixed time stepping. </p>

<a name="class_ni_phys_x_scene_1ad3c2a2c215fb71bf28f7f5bc447d864d"></a>
<p class="NDLRefMemberFunction">void  SetTimestep(const float fStep)</p>
<p class="NDLRefMemberDescription">Set the timestep that Gamebryo uses with fixed time stepping. </p>
<p class="NDLRefMemberDetailedDescription">Default is 1.0 / 60.0. </p>

<a name="class_ni_phys_x_scene_1a3f2ef3ba8284d9f564714aed162e7bfe"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">NiUInt32</span>  GetNumSubSteps() const</p>
<p class="NDLRefMemberDescription">Get the number of steps that each Gamebryo step is broken into before being passed to PhysX. </p>
<p class="NDLRefMemberDetailedDescription">For example, if GetNumSubSteps returns 2, then each PhysX time step is half of the value returned by GetTimestep (above). </p>

<a name="class_ni_phys_x_scene_1a5808e86bb2fc9a4dafd1087386dfe683"></a>
<p class="NDLRefMemberFunction">void  SetNumSubSteps(const <span class="NDLSystemFont">NiUInt32</span> uiNumSteps)</p>
<p class="NDLRefMemberDescription">Set the number of steps that each Gamebryo step is broken into before being passed to PhysX. </p>
<p class="NDLRefMemberDetailedDescription">For example, if SetNumSubSteps is set to 4, then each PhysX time step is one quarter of the value returned by GetTimestep (above).</p>
<p class="NDLRefMemberDetailedDescription">Default is 1. </p>

<a name="class_ni_phys_x_scene_1ac9f6d31f5658804a11f3b941aa7e5ac5"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">NiUInt32</span>  GetMaxSubSteps() const</p>
<p class="NDLRefMemberDescription">Get the maximum number of steps that PhysX will be asked to take. </p>

<a name="class_ni_phys_x_scene_1aa45b9887f07777567baef011c731cb55"></a>
<p class="NDLRefMemberFunction">void  SetMaxSubSteps(const <span class="NDLSystemFont">NiUInt32</span> uiMaxSteps)</p>
<p class="NDLRefMemberDescription">Set the maximum number of steps that PhysX will be asked to take. </p>
<p class="NDLRefMemberDetailedDescription">Default is 8. </p>

<a name="class_ni_phys_x_scene_1a85db568f5041ac5930512417207f2049"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  GetAsynchronousSimulation() const</p>
<p class="NDLRefMemberDescription">Get the asynchronous simulation flag. </p>
<p class="NDLRefMemberDetailedDescription">When true, the PhysX simulation is running in parallel with rendering. </p>

<a name="class_ni_phys_x_scene_1a3c36d01bc630402329f2792c2ed9d357"></a>
<p class="NDLRefMemberFunction">void  SetAsynchronousSimulation(const <span class="NDLSystemFont">bool</span> bActive)</p>
<p class="NDLRefMemberDescription">Set the asynchronous simulation flag. </p>
<p class="NDLRefMemberDetailedDescription">This flag must be set to true if the PhysX simulation is being done in parallel with rendering, or false otherwise. Failure to correctly set it may result in poor performance, PhysX errors, or even deadlock. </p>

<a name="class_ni_phys_x_scene_1a9b8cadcd71f4be06197c0935e96474cd"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../NiFloodgate/NiSPWorkflowManager.htm">NiSPWorkflowManager</a></span>*  GetWorkflowManager() const</p>
<p class="NDLRefMemberDescription">Get the workflow manager that is being used for mesh modifiers. </p>

<a name="class_ni_phys_x_scene_1a55f0c81aedcdf8c215686c0db8740e5e"></a>
<p class="NDLRefMemberFunction">void  SetWorkflowManager(<span class="NDLSystemFont"><a href="../NiFloodgate/NiSPWorkflowManager.htm">NiSPWorkflowManager</a></span>* pkWorkflowManager)</p>
<p class="NDLRefMemberDescription">Set the workflow manager to be used for mesh modifiers. </p>
<p class="NDLRefMemberDetailedDescription">Any existing, locally owned manager is deleted. </p>

<a name="class_ni_phys_x_scene_1af27af4c3fe277537204f059baec53f1f"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  GetInSimFetch() const</p>
<p class="NDLRefMemberDescription">Returns whether or not the scene is currently within a simulate/fetchResults pair. </p>
<p class="NDLRefMemberDetailedDescription">This is important information, because many actions on the PhysX SDK are prohibited during such times. This state may not always be easy to keep track of in applications, due to fixed length timesteps, asynchronous simulation or multi-threading. This function guarantees that, if the calling thread holds the PhysX SDK lock from <span class="NDLSystemFont"><a href="../efdPhysX/efdPhysX__PhysXSDKManager.htm">efdPhysX::PhysXSDKManager</a></span>, calls this function and receives false, then the simulate/fetchResults pair will not be entered until the lock is released. Threads can hence safely manipulate the SDK while they continue to hold the lock. See the Multithreading documentation in the Programmer's Guide for information on using the SDK lock. </p>

<a name="class_ni_phys_x_scene_1ac1f5c6c3b715ce5a995301ac896be482"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  Simulate(<br/>const float fTargetTime, <br/>const <span class="NDLSystemFont">bool</span> bForceSim = false)</p>
<p class="NDLRefMemberDescription">Enter a simulation step. </p>
<p class="NDLRefMemberDetailedDescription">The function returns true if the step was actually started. It will return false if it is already within a simulate/fetchResults pair or if the target time has already been simulated to. You can force simulation with the bForceSim flag, but this might result in a zero length step. </p>

<a name="class_ni_phys_x_scene_1ac730f723f9649aa93578bd40058cc289"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  FetchResults(<br/>const float fTargetTime, <br/>const <span class="NDLSystemFont">bool</span> bBlock = false, <br/>NxU32* puiErrorState = 0)</p>
<p class="NDLRefMemberDescription">Fetch the results of a simulation step. </p>
<p class="NDLRefMemberDetailedDescription">This function returns true if the results were actually fetched. It blocks on results if the target time is greater than the most recent simulation results or if forced to do so by the bBlock argument. When using fixed timesteps, the function may return false because there is already sufficient state to cover the requested time, in which case the application is still inside the simulate/fetchResults pair. This function also returns true if not in simulate/fetchResults when it is called. The puiErrorState argument is passed directly to PhysX to catch any hardware error code. </p>

<a name="class_ni_phys_x_scene_1a7a673e90777cbe102072d7a267a05fae"></a>
<p class="NDLRefMemberFunction">void  SetFetchTime(const float fCurrentTime)</p>
<p class="NDLRefMemberDescription">Set the time that this scene was most recently simulated to. </p>
<p class="NDLRefMemberDetailedDescription">The PhysX scene works only on incremental time, so the <span class="NDLSystemFont">NiPhysXScene</span> maintains its own absolute time measurement. This function resets that time. This should not be done while inside a simulate/fetchResults pair. It should always be done before simulation begins, and can also be done whenever it is necessary to re-synchronize application and PhysX time. </p>

<a name="class_ni_phys_x_scene_1ab520e308fde951ba96abbbaa465c1570"></a>
<p class="NDLRefMemberFunction">float  GetPrevFetchTime() const</p>
<p class="NDLRefMemberDescription">Get the most recent time that this scene was simulated to. </p>
<p class="NDLRefMemberDetailedDescription">If currently in a simulate/fetchResults pair, then the time is the start time for this step. </p>

<a name="class_ni_phys_x_scene_1a4fa1c10aab5ab6f706cc63bc9dba3f78"></a>
<p class="NDLRefMemberFunction">float  GetNextFetchTime() const</p>
<p class="NDLRefMemberDescription">Returns the time that we are currently simulating to. </p>
<p class="NDLRefMemberDetailedDescription">This value is only valid when the scene is within a simulate/fetchResults pair (i.e. when GetInSimFetch returns true). </p>
<a name="snapshots"></a>
<p class="NDLRefHead1">Snapshots</p>

<p class="NDLRefMemberDescription">A snapshot is the state of all the Gamebryo-supported elements of a PhysX scene.</p>
<p class="NDLRefMemberDescription">The snapshot is used to stream the PhysX content and to provide save and restore functionality on actor poses and velocities.</p>
<p class="NDLRefMemberDescription">Each <span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span> attached to the scene keeps a single snapshot (possibly NULL), which in turn contains multiple snapshot states for each actor, cloth and material. The individual actor states can be accessed directly, or the functions below can be used to operate on all actors in the scene. The two approaches should not be mixed because the state indexes will become confused. </p>

<a name="class_ni_phys_x_scene_1ae882a90495e64245712acdbbae117938"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">NiUInt32</span>  AddSnapshotState(<span class="NDLSystemFont"><a href="../NiMain/NiFixedString.htm">NiFixedString</a></span>& kName)</p>
<p class="NDLRefMemberDescription">Add a new set of actor poses and velocities, cloth vertex positions, and material properties, to the snapshots for all of the props in the scene. </p>
<p class="NDLRefMemberDetailedDescription">The poses are taken from the current state of the scene. Only actors, cloth and materials already in a snapshot are captured. Do not mix this function with <span class="NDLSystemFont"><a href="NiPhysXActorDesc.htm#class_ni_phys_x_actor_desc_1aea06656c1e6cdef8e3a5d4c0981716e2">NiPhysXActorDesc::AddState</a></span> and similar functions; use one or the other. </p>

<a name="class_ni_phys_x_scene_1a1888c88cbc57c1feb68362fcbb83d22f"></a>
<p class="NDLRefMemberFunction">void  RestoreSnapshotState(const <span class="NDLSystemFont">NiUInt32</span> uiIndex)</p>
<p class="NDLRefMemberDescription">Restore the cached state for the specific index. </p>
<p class="NDLRefMemberDetailedDescription">This resets all of the positions and velocities in the scene. </p>

<a name="class_ni_phys_x_scene_1a4cecc6acb0d0137fdc9bb27a0c925247"></a>
<p class="NDLRefMemberFunction">void  RestoreSnapshotState(const <span class="NDLSystemFont"><a href="../NiMain/NiFixedString.htm">NiFixedString</a></span>& kName)</p>
<p class="NDLRefMemberDescription">Restore the cached state for the specific named state. </p>
<p class="NDLRefMemberDetailedDescription">This resets all of the positions and velocities in the scene. </p>

<a name="class_ni_phys_x_scene_1a2056241999da91031eb5c996626143ee"></a>
<p class="NDLRefMemberFunction">virtual void  RemoveSnapshotState(<span class="NDLSystemFont"><a href="../NiMain/NiFixedString.htm">NiFixedString</a></span>& kName)</p>
<p class="NDLRefMemberDescription">Remove a single stored state, by name. </p>
<p class="NDLRefMemberDetailedDescription">Convenience function that simply calls the corresponding function on all props. </p>

<a name="class_ni_phys_x_scene_1ae3cd1d0ca79d6c1e69cb6a3be47de9b9"></a>
<p class="NDLRefMemberFunction">virtual void  RemoveSnapshotState(<span class="NDLSystemFont">NiUInt32</span> uiIndex)</p>
<p class="NDLRefMemberDescription">Remove a single stored state, by index. </p>
<p class="NDLRefMemberDetailedDescription">Convenience function that simply calls the corresponding function on all props. </p>

<a name="class_ni_phys_x_scene_1ac242ce273da197f23f57fcd327380e04"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="NiPhysXSceneDesc.htm">NiPhysXSceneDesc</a></span>*  GetSnapshot()</p>
<p class="NDLRefMemberDescription">Returns the snapshot for this scene, which is a smart pointer passed as a regular pointer for simplicity. </p>
<p class="NDLRefMemberDetailedDescription">The snapshot for the scene itself contains only data required to recreate the NxScene object. Snapshot data for objects in the scene is found in the attached props' snapshots. </p>

<a name="class_ni_phys_x_scene_1a77363873c51b31c8fdfe1bc69d70bead"></a>
<p class="NDLRefMemberFunction">void  SetSnapshot(<span class="NDLSystemFont"><a href="NiPhysXSceneDesc.htm">NiPhysXSceneDesc</a></span>* pkSnapshot)</p>
<p class="NDLRefMemberDescription">Sets the snapshot, which is internally stored as a smart pointer. </p>
<p class="NDLRefMemberDetailedDescription">Applications should not delete the memory themselves. </p>

<a name="class_ni_phys_x_scene_1a16a4588392ddbb94f5a1c643a8fad29d"></a>
<p class="NDLRefMemberFunction">void  ReleaseSnapshot()</p>
<p class="NDLRefMemberDescription">Sets the internal smart pointer to the snapshot to 0. </p>
<p class="NDLRefMemberDetailedDescription">Applications must not continue to hold a smart pointer to the snapshot after this function is called. </p>

<a name="class_ni_phys_x_scene_1a7f2083d5e5a1c4cec3d1252f4dc18b20"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  CreateSceneFromSnapshot(const <span class="NDLSystemFont">NiUInt32</span> uiIndex = 0)</p>
<p class="NDLRefMemberDescription">Create a PhysX scene and fill it from the snapshots contained in props that have been added to the scene. </p>
<p class="NDLRefMemberDetailedDescription">Any existing NxScene object held by this scene is released, and a new NxScene object is created. Scene properties stored in the snapshot define the properties of the new scene. Any props in the scene are instantiated in the new scene. The index is the state index to use in setting poses, which should be 0 unless a tool or application has added additional states to the snapshot.</p>
<p class="NDLRefMemberDetailedDescription">This function requires the existence of a snapshot on this object. In many cases, it is more convenient to create the NxScene object explicitly, set it on this scene, and then add props. The result is the same as adding props first, creating a snapshot for this object, and then calling this function. </p>

<a name="class_ni_phys_x_scene_1ac462258ec14b1db4a75179ebcedf25d3"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  CreateSceneFromSnapshot(const <span class="NDLSystemFont"><a href="../NiMain/NiFixedString.htm">NiFixedString</a></span>& kName)</p>
<p class="NDLRefMemberDescription">Create a PhysX scene and fill it from the snapshots contained in props that have been added to the scene. </p>
<p class="NDLRefMemberDetailedDescription">See the version of CreateSceneFromSnapshot above. This function uses a name to look up the initial conditions but is otherwise identical. </p>
<a name="update_functions_for_sources_and_destinations"></a>
<p class="NDLRefHead1">Update Functions for Sources and Destinations</p>

<p class="NDLRefMemberDescription"><span class="NDLSystemFont">NiPhysXScene</span> objects control the updating of the sources and destinations within them.</p>
<p class="NDLRefMemberDescription">The following functions control various aspects of updates. </p>

<a name="class_ni_phys_x_scene_1a9e320f0b7efa3db7caf5e08babb4275b"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  GetUpdateSrc() const</p>
<p class="NDLRefMemberDescription">Get the flag controlling the updating of sources. </p>
<p class="NDLRefMemberDetailedDescription">If false, no information is collected from Gamebryo objects nor pushed to PhysX actors, regardless of which other functions are called. </p>

<a name="class_ni_phys_x_scene_1a32b44fbac4ea3e0209aed2fe8ca9fc7e"></a>
<p class="NDLRefMemberFunction">void  SetUpdateSrc(const <span class="NDLSystemFont">bool</span> bActive)</p>
<p class="NDLRefMemberDescription">Set the flag controlling updating of sources. </p>
<p class="NDLRefMemberDetailedDescription">Default is false. </p>

<a name="class_ni_phys_x_scene_1a13013210909faf49cb76f9864dc18f44"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont">bool</span>  GetUpdateDest() const</p>
<p class="NDLRefMemberDescription">Get the flag controlling the updating of destinations. </p>
<p class="NDLRefMemberDetailedDescription">If false, no information is collected from PhysX actors nor pushed to Gamebryo nodes, regardless of which other functions are called. </p>

<a name="class_ni_phys_x_scene_1a9356537b8a08a215caaa299305c98c4f"></a>
<p class="NDLRefMemberFunction">void  SetUpdateDest(const <span class="NDLSystemFont">bool</span> bActive)</p>
<p class="NDLRefMemberDescription">Set the flag controlling updating of destinations. </p>
<p class="NDLRefMemberDetailedDescription">Default is false. </p>

<a name="class_ni_phys_x_scene_1a89cf7f37782aaa660d3d128539ec337b"></a>
<p class="NDLRefMemberFunction">void  AddSource(<span class="NDLSystemFont"><a href="NiPhysXSrc.htm">NiPhysXSrc</a></span>* pkSrc)</p>
<p class="NDLRefMemberDescription">Add a source. </p>
<p class="NDLRefMemberDetailedDescription">This function should only be used if PhysX actors are being created completely outside of the <span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span> system. Any source associated with a <span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span> object is automatically added to the scene when the prop is added, and adding it again is an error. </p>

<a name="class_ni_phys_x_scene_1a14e3e2816c80a944d5c778e40a59b410"></a>
<p class="NDLRefMemberFunction">void  DeleteSource(<span class="NDLSystemFont"><a href="NiPhysXSrc.htm">NiPhysXSrc</a></span>* pkTarget)</p>
<p class="NDLRefMemberDescription">Delete a source. </p>
<p class="NDLRefMemberDetailedDescription">This function should only be used if PhysX actors are being created completely outside of the <span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span> system. Any source associated with a <span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span> object is automatically removed from the scene when the prop is removed, and removing it again is an error. </p>

<a name="class_ni_phys_x_scene_1a3f9721989b6b3e72e2ca88f245c3bdb1"></a>
<p class="NDLRefMemberFunction">void  AddDestination(<span class="NDLSystemFont"><a href="NiPhysXDest.htm">NiPhysXDest</a></span>* pkDest)</p>
<p class="NDLRefMemberDescription">Add a destination. </p>
<p class="NDLRefMemberDetailedDescription">This function should only be used if PhysX actors are being created completely outside of the <span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span> system. Any destination associated with a <span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span> object is automatically added to the scene when the prop is added, and adding it again is an error. </p>

<a name="class_ni_phys_x_scene_1a5149399d086ba7fa719c8e841ec51d4b"></a>
<p class="NDLRefMemberFunction">void  DeleteDestination(<span class="NDLSystemFont"><a href="NiPhysXDest.htm">NiPhysXDest</a></span>* pkTarget)</p>
<p class="NDLRefMemberDescription">Delete a destination. </p>
<p class="NDLRefMemberDetailedDescription">This function should only be used if PhysX actors are being created completely outside of the <span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span> system. Any destination associated with a <span class="NDLSystemFont"><a href="NiPhysXProp.htm">NiPhysXProp</a></span> object is automatically removed from the scene when the prop is removed, and removing it again is an error. </p>

<a name="class_ni_phys_x_scene_1a25b17b6cb10936c6afd3f55fe41d1a50"></a>
<p class="NDLRefMemberFunction">void  UpdateSources(<br/>const float fTime, <br/><span class="NDLSystemFont">bool</span> bForce = false)</p>
<p class="NDLRefMemberDescription">Update all the sources associated with this scene. </p>
<p class="NDLRefMemberDetailedDescription">The set of sources includes all the sources in any prop attached to the scene. This is typically done before a simulation step to set the state for Gamebryo-controlled actors. The time is Gamebryo application time, and it is up to individual sources to determine how best to set the state for the given time. In most cases, no update will be done if the internal PhysX time is already at or past the requested time, except if bForce is true, in which case the update is always done. This function does nothing if the update sources flag is not set, and individual sources will not be updated if their own active flag is not set. There is no guarantee on the order in which sources will be updated. </p>

<a name="class_ni_phys_x_scene_1ad0ba9d929463d41fea4a4b0d990893ae"></a>
<p class="NDLRefMemberFunction">void  UpdateDestinations(<br/>const float fTime, <br/><span class="NDLSystemFont">bool</span> bForce = false)</p>
<p class="NDLRefMemberDescription">Update all the destinations associated with this scene. </p>
<p class="NDLRefMemberDetailedDescription">This function is typically called by applications after a simulation step. The time is Gamebryo application time, and it is up to individual destinations to determine how best to set the state for the given time. In most cases, no update will be done if the internal PhysX time is already at or past the requested time, except if bForce is true, in which case the update is always done. This function does nothing if the update destinations flag is not set, and individual destinations will not be updated if their own active flag is not set. There is no guarantee on the order in which destinations will be updated. </p>

<a name="class_ni_phys_x_scene_1a49cfe5b2c870c101ee9d67cc6a61436d"></a>
<p class="NDLRefMemberFunction">void  UpdateSource(<br/><span class="NDLSystemFont"><a href="NiPhysXSrc.htm">NiPhysXSrc</a></span>* pkSrc, <br/>const float fTime, <br/>const <span class="NDLSystemFont">bool</span> bForce = false)</p>
<p class="NDLRefMemberDescription">Update a single source. </p>
<p class="NDLRefMemberDetailedDescription">Arguments are as above for UpdateSources. This update is done regardless of the value returned by GetUpdateSrc. </p>

<a name="class_ni_phys_x_scene_1a0662e8ce2b89b420d154b772751d4f4c"></a>
<p class="NDLRefMemberFunction">void  UpdateDestination(<br/><span class="NDLSystemFont"><a href="NiPhysXDest.htm">NiPhysXDest</a></span>* pkDest, <br/>const float fTime, <br/>const <span class="NDLSystemFont">bool</span> bForce = false)</p>
<p class="NDLRefMemberDescription">Update a single destination. </p>
<p class="NDLRefMemberDetailedDescription">Arguments are as above for UpdateDestinations. This update is done regardless of the value returned by GetUpdateDest. </p>
 
<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

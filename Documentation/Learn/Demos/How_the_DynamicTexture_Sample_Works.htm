<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>How the DynamicTexture Sample Works</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2"
type="text/javascript">
</script><script language="JavaScript1.2" type="text/javascript">
WriteNavLink(2);
</script>

<h1>How the DynamicTexture Sample Works</h1>

<p>The rendering code for this sample is designed to be as simple
as possible in order to avoid detracting from the central message
of the example&mdash;namely, the creation and per-frame update of
the dynamic procedural texture. Those steps appear in
<span class="NDLSystemFont">DynamicTexture::UpdateNoiseImage</span>,
the function that writes the Perlin noise values into the texture
and handles the bookkeeping.</p>

<h2>CreateScene</h2>

<p><span class="NDLSystemFont">DynamicTexture::CreateScene</span>
calls the <span class="NDLSystemFont">NiApplication</span> (base
class) version, initializes the noise function with a call to
<span class=
"NDLSystemFont">DynamicTexture::UpdateNoiseImage</span>, calls
<span class="NDLSystemFont">DynamicTexture::CreatePolygon</span>
to create the visible screen-space geometry (an <a href=
"../../Reference/NiMesh/NiMeshScreenElements.htm"><span class=
"NDLSystemFont">NiMeshScreenElements</span></a> object with a
single rectangle), and then finishes by attaching the
screen-space geometry to the <span class=
"NDLSystemFont">NiApplication</span> array of these objects for
automatic rendering.</p>

<h2>OnIdle</h2>

<p>The rendering function (<span class=
"NDLSystemFont">OnIdle</span>) adds only two lines of code to the
base class version: <span class=
"NDLSystemFont">DynamicTexture::OnIdle</span> increments the
<span class="NDLSystemFont">m_fSlide</span> value (which causes
the texturing effect to animate over time by sliding the noise
function across the texture), updates the procedural texture with
a call to <span class=
"NDLSystemFont">DynamicTexture::UpdateNoiseImage</span>, and
calls the base class to render the scene.</p>

<h2>UpdateNoiseImage</h2>

<p><span class=
"NDLSystemFont">DynamicTexture::UpdateNoiseImage</span> serves
two purposes: to allocate the <a href=
"../../Reference/NiMain/NiDynamicTexture.htm"><span class=
"NDLSystemFont">NiDynamicTexture</span></a> object (if it does
not yet exist), and to update/animate the dynamic procedural
texture. The latter step is accomplished by locking the device
texture (which enables editing of its pixels), re-computing all
of the texels, and unlocking the device texture (which marks an
end to pixel edits).</p>

<p>First, if the member pointer to <span class=
"NDLSystemFont">m_spIm</span>, the dynamic procedural texture
object, is <span class="NDLSystemFont">NULL</span>, the function
allocates a 64x64 texel dynamic texture. The renderer tries to
find a device texture format that matches the TRUE_COLOR_32
format preference as closely as possible. This object will serve
as the destination of the procedural texture code, and its texels
will be assigned colors generated by the procedural texture code.
It will also serve as the texture that will be applied to the
visible screen-space geometry.</p>

<p>The core of the function is the double loop that follows the
initialization of the pixel data object. For each texel in the
texture, the code looks up a noise value. This noise value is
parameterized by planar X and Y values, ensuring that the texture
is coherent frame to frame (simply calling <span class=
"NDLSystemFont">rand()</span> for each frame would lead to
random, sparkling noise, rather than a temporally coherent
image). The returned value of this function is a normalized
floating-point value in the range [0.0, 1.0].</p>

<p>In order to generate convincing clouds, the returned per-pixel
scalar value is used to compute a linear fade between [0x70,
0xB0, 0xF0] (a blue sky color) and [0xF0, 0xF0, 0xF0] (a white
cloud color). The resulting color is placed in the current texel.
Other color fades (such as red to yellow, etc.) may be used to
build other effects, such as fire and smoke. Since the pixel data
format is known at compile time to have 8 bits each of red,
green, blue, and padding, the code simply treats the dynamic
texture as a contiguous array, filling each pixel and stepping to
the next.</p>

<p>Because dynamic textures are created using renderer-specific
(actually, device-specific) formats, the TRUE_COLOR_32 format
preference may have a different ordering of components on
different devices. For this reason, the <span class=
"NDLSystemFont">GetShift()</span> and <span class=
"NDLSystemFont">GetMask()</span> methods of the <a href=
"../../Reference/NiMain/NiPixelFormat.htm"><span class=
"NDLSystemFont">NiPixelFormat</span></a> are used to figure out
the sequential layout of red, green, blue, and padding channels
directly from the pixel format, in a device-agnostic way.</p>

<h2>CreatePolygon</h2>

<p><span class=
"NDLSystemFont">DynamicTexture::CreatePolygon</span> generates
the single piece of rendered geometry in this demo&mdash;a
rectangular screen-space polygon in an <a href=
"../../Reference/NiMesh/NiMeshScreenElements.htm"><span class=
"NDLSystemFont">NiMeshScreenElements</span></a> object that fills
most of the view. The code creates a simple rectangle in the
<a href=
"../../Reference/NiMesh/NiMeshScreenElements.htm"><span class=
"NDLSystemFont">NiMeshScreenElements</span></a> object, using
only vertex positions and texture UVs. The texture coordinates
map the entire texture across the polygon. Only two properties
are attached: a texturing property and a dithering property. The
texturing property attaches the procedural texture as the base
texture (already assumed to be valid), and sets the texture mode
to <span class="NDLSystemFont">APPLY_REPLACE</span>, ensuring
that the texture is rendered directly. The dithering property is
attached in order to ensure that the resulting image on 16-bit
framebuffers is not heavily banded (this can happen with this
kind of cloud texture, and tends to draw attention to the nature
of the noise function).</p>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

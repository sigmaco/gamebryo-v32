<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
 
<html>
<head>

<title>Modeling Principles</title>

<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Expedition" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2"
type="text/javascript">
</script><script language="JavaScript1.2" type="text/javascript">
WriteNavLink(2);
</script>

<h1>Modeling Principles</h1>

<p>Modeling is the process of creating a simplified
representation of a desired system. In 3d graphics, it is often a
polygonal model. In software engineering, it is a visual (often
UML) representation of the classes and code. In simulation it is
representing interesting elements of the desired system at some
level of detail, and usually doing so in software. In some cases,
scale-models of aircraft and vessels are physically
constructed.</p>

<p>In the game industry, logical gameplay is a software model of
the system the game designer envisioned. That could be an
imaginary part of outer space, or a realistic combat situation.
The designer and implementer decide which elements of the system
will be represented, and at what level of detail. The elements
are referred to as Entities, and the implementation of the
classes of systems and subsystems they represent are called
Models. In some circles, Entities are referred to as game
objects.</p>

<p>One of the most valuable decisions that is made when creating
a model, is what is left out. Painfully detailed representations
may be completely obscured by other decisions in the game, and
much time can be saved by abstracting away such details. In some
cases, creating a dynamic level of detail is possible, and can
save computational resources.</p>

<h2>Decomposing Entities with Models</h2>

<p>The virtual world is composed of many objects called Entities.
These Entities are grouped into different classes called Models.
Models are composed of Properties, Behaviors, and other Models.
These primitives can be used to realize an arbitrarily complex
world. It is up to the application to decide exactly how to
decompose their world into these pieces.</p>

<p>The development of Game Entities is a long and complex process
that can be greatly simplified using object oriented techniques.
It has been shown that fixed hierarchies of classes of Entities
is not an effective way to decompose the game world. The Game
Framework provides a component-based Entity system with several
innovations to further ease the task facing a game designer.</p>

<p>As an object oriented class, a Model contains a set of typed
Properties and associated Behaviors. The Game Framework also
provides for setting initial values of each Property. This
facility can be used to create a palette of preset Entity
templates from which an initial world is constructed.</p>

<p>An Entity Model can be considered both an Entity class or
subclass, and an Interface that can be extended in derived
Models. Note that a Model is not limited to being a visual model,
but may encapsulate behavioral logic and game state.</p>

<p>Each Entity has an associated Model that is shared by all
other instances of the same kind of Entity. A Model is static at
runtime, and can be created interactively using the Entity
Modeling Tool in Toolbench. Since a Model definition is
data-driven it enables rapid iteration of the definition of sets
of Entities. The default values for Property descriptions in a
Model can be tuned, also affecting sets of Entities.</p>

<h2>Models and Mix-ins</h2>

<p>The Emergent Game Framework uses a Mix-in metaphor of
inheritance to relate one Model to another. This means outer
Models are constructed by "Mixing in" inner models in a specific
order. One of the purposes of the Mix-in system is to avoid
complications that arise from fixed inheritance hierarchies and
multiple inheritance. We automatically resolve Properties and
Behaviors inherited from two parents that have the same name. It
results in a simplified "virtual inheritance" similar to the C++
concept, but resolved at the member level, not the class
level.</p>

<p>When an outer Model mixes-in an inner Model(s), it acts like
inheritance. The outer Model now exhibits the interface and
Properties of the inner model. It can override the Behaviors of
the inner Model, and therefore specialize. In these senses, an
outer Model is-a, or is-like-an inner Model. The outer Model can
also extend (adds-to) the inner Model(s) by adding new Properties
and Behaviors.</p>

<p>Another way to look at mixing in is as an
is-made-of-the-contents-of-a relationship between two Models. It
might also be thought of as an optimized is-made-of-a
relationship between the two Models or Entities.</p>

<p>This multi-purpose ability of mix-ins is why we often refer to
the relationships between Models both as inheritance and
composition.</p>

<h2>Interfaces</h2>

<p>A Model can be thought of as an Interface, particularly if it
is defined with only Behavior definitions. This means that any
Entity that has a particular Model mixed in, it can always be
used-as-an instance of that Model. Since a Behavior
implementation can be overridden by a derived Entity, this
automatically provides polymorphism.</p>

<h2>Philosophy</h2>

<p>This is a summary of the benefits of the Gamebryo Entity Model
system:</p>

<ul>
    <li>Data driven, allowing rapid iteration by updating Model
    and Entity definitions without restarting the
    application</li>

    <li>By recognizing tightly related Models, tuning can be
    performed in tables.</li>

    <li>Multiple inheritance provides good reuse.</li>

    <li>Composition is nice for reuse, orthogonality, and
    richness of the world.</li>

    <li>Support for dynamic composition through Properties of
    type Entity Reference.</li>

    <li>Mix-in resolves collisions and can allow composition of
    new types of entities without coding "glue".</li>
</ul>

<p class="NDLHeadingRelatedTopic">Related topics</p>

<ul>
    <li><a href="entity_models_overview.htm">Models
    overview</a></li>

    <li><a href="entity_models_best_practice.htm">Best practices
    for working with models</a></li>

    <li><a href="entity_models_examples.htm">Model
    examples</a></li>

    <li><a href="entity_models_using.htm">Using models</a></li>
</ul>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>
</html>

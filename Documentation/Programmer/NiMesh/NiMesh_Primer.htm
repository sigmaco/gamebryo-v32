<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>NiMesh Primer</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script> <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<h1>NiMesh Primer</h1>

<p>This document is intended to be a basic introduction 
 to the <span class="NDLSystemFont">NiMesh</span> API. For more details, 
 please see the <a href="Introduction_to_NiMesh_Data.htm">Working 
 With NiMesh Data</a> and <a href="Creating_an_NiMesh_Object.htm">Creating 
 an NiMesh Object</a> topics.</p>

<a name=Terminology></a><h2>Terminology</h2>

<ul>
	
	<li>Stream  A stream is 
 an abstraction of a contiguous buffer of data that holds one or more vertex, 
 index, or user-defined elements.</li>
	
	<li>Usage - Each stream 
 encapsulates a buffer that is used by the application for a specific purpose. 
 Gamebryo supports three usage types to meet these renderer needs:
	
	<ul>
		
		<li><span class="NDLSystemFont">USAGE_VERTEX</span> 
 - this usage type is for per-vertex data.</li>
		
		<li><span class="NDLSystemFont">USAGE_VERTEX_INDEX</span> 
 - this usage type is for per-index data</li>
		
		<li><span class="NDLSystemFont">USAGE_USER</span> 
 - this usage type is for data consumed by the application. The Gamebryo 
 renderer uses user streams for arrays of shader constants in some cases.</li>
	</ul>
	
	</li>
	
	<li>Element - An element 
 is an array of data that supplies a single input variable (varying or 
 uniform) to a shader program. Each stream element defines a format and 
 an offset where a particular element may be found for a given stream. 
 Multiple elements may be interleaved into a single stream.</li>
	
	<li>Region  A Region defines 
 a contiguous subset of a stream. The elements must be the same across 
 all regions in a stream. Every region contains the following data:
	
	<ul>
		
		<li>the base offset 
 into each stream</li>
		
		<li>the active number 
 of elements for the Region</li>
	</ul>
	</li>
</ul>

<ul>
	
	<li>NiMesh - the Gamebryo 
 class that encapsulates a piece of geometric data that is affected by 
 a unique set of dynamic effects (lights, projected textures, etc) and 
 properties (textures, material properties, etc). </li>
	
	<li>Sub-mesh - self-contained 
 parts of an <span class="NDLSystemFont">NiMesh</span> object that correspond 
 to a unique draw call in the renderer. An <span class="NDLSystemFont">NiMesh</span> 
 object will have at least one sub-mesh. Additional sub-meshes are generally 
 created when all of the data needed for rendering will not fit into the 
 limitations of the graphics hardware (for example, when a single sub-mesh 
 would require too many bones for skinning). Regions may be used with sub-meshes 
 to enable multiple draws per geometry object without switching streams, 
 which can be a performance penalty under some architectures.</li>
</ul>

<a name=Semantics></a><h2>Semantics</h2>

<p>Semantics are strings (specifically, case sensitive 
 <a href="../../Reference/NiMain/NiFixedString.htm"><span 
 class="NDLSystemFont">NiFixedString</span></a> objects) that help uniquely 
 identify an <em>element</em> by standard 
 usage (for example, <span class="NDLSystemFont">POSITION</span>, <span class="NDLSystemFont">COLOR</span>, 
 <span class="NDLSystemFont">NORMAL</span>, and so on) or a custom defined usage (for example, <span class="NDLSystemFont">GRIMINESS</span>, <span class="NDLSystemFont">FUR_LENGTH</span>, and so on). Custom semantics may be generated by the content creation tools. 
 To uniquely identify elements, a semantic along with an index is used, 
 as a semantic may be used multiple times (for example, texture coordinates).</p>

<p>The mapping of these generic semantic/index pairs to 
 renderer-specific semantic/index pairs is managed by a data structure 
 called a <a href="../../Reference/NiMain/NiSemanticAdapterTable.htm">Semantic 
 Adapter Table</a>. &nbsp;Every 
 material instance has one, and it will be constructed automatically if 
 not specified by the material or a shader. &nbsp;These 
 automatic mappings assume a 1:1 relationship between renderer and generic 
 semantics (e.g., TEXCOORD:3 would work on renderers as that is a valid 
 renderer semantic, but UV:3 would not. &nbsp;UV 
 could be mapped to TEXCOORD with a custom semantic adapter table however).</p>

<p>Data streams that are not consumed by the shader don't 
 need to have an entry in the Semantic Adapter Table. &nbsp;A 
 common example is the morph target streams used by the <span class="NDLSystemFont"><a 
 href="../../Reference/NiMesh/NiMorphMeshModifier.htm">NiMorphMeshModifier</a></span> 
 class.</p>

<p>Elements, identified by semantic and index, may be accessed 
 via iterators that hide the details of stream-element layout and interleaving. 
 See <a href="Data_Stream_Lock_and_Iterator_Objects.htm">Data 
 Stream Lock and Iterator Objects</a> for more information on iterators.</p>

<a name=Streams_and_Regions_Meshes_and_submeshes></a><h2>Streams 
 and Regions; Meshes and sub-meshes</h2>

<p>As noted in the Terminology section, each stream 
 of data represents a contiguous buffer holding one or more elements. 
 The class that embodies this concept is <span 
 class="NDLSystemFont"><a href="../../Reference/NiMesh/NiDataStream.htm">NiDataStream</a></span>, which represents this buffer 
 and the elements contained in it. Each <span class="NDLSystemFont">NiDataStream</span> 
 instance has an array of <em>regions</em> (<span 
 class="NDLSystemFont"><a 
 href="../../Reference/NiMesh/NiDataStream__Region.htm">NiDataStream::Region</a></span>)
 and an array of elements (<span 
 class="NDLSystemFont"><a 
 href="../../Reference/NiMesh/NiDataStreamElement.htm">NiDataSteamElement</a></span>. 
 </p>

<p>An <span class="NDLSystemFont">NiMesh</span> object holds 
 an array of <span class="NDLSystemFont"><a href="../../Reference/NiMesh/NiDataStreamRef.htm">NiDataStreamRefs</a></span>, 
 which themselves contain a smart pointer reference to a <span class="NDLSystemFont">NiDataStream 
 </span>instance, as well as instancing parameters for use with <a href="Introduction_to_Instancing.htm">GPU 
 instancing</a>. Additionally, each <span class="NDLSystemFont">NiDataStreamRef</span> 
 contains an array of indices that specify which <span class="NDLSystemFont">NiDataStream 
 </span><em>region</em> to use for rendering 
 a particular <em>sub-mesh.</em> In order 
 to identify each unique <em>element</em> 
 in the <em>stream</em>, the <span class="NDLSystemFont">NiDataStreamRef 
 </span>contains the <em>semantic</em> 
 and <em>index</em> mapping mentioned in 
 the previous section. It is useful to have the semantic mapping on a per-mesh 
 basis so that the same stream can be shared as much as possible, as sharing 
 only requires format compatibility and not semantic compatibility.</p>

<p>The following diagram demonstrates the relationships 
 between <span class="NDLSystemFont">NiDataStream</span> objects, <span class="NDLSystemFont">NiDataStreamElement</span> 
 objects, &nbsp;<span class="NDLSystemFont">NiMesh</span> 
 objects and <span class="NDLSystemFont">NiDataStreamRef</span> objects:</p>


<div class="NDLFigureContainer">
    <img src="./images/DataStreamRegionsMeshesAndRefs3.jpg" width="732" height="506" />
    <p class="NDLFigureCaption">NiDataStream - NiDataStreamElement - NiMesh - NiDataStreamRef object relationships</p>
</div>


<p>In this example, there is a stream 
 with sixteen vertices. The stream 
 has been broken up into two equally-sized regions. 
 Each vertex actually has three interleaved, uniquely addressable elements stored in an <span class="NDLSystemFont">NiDataStreamElementSet</span>. 
 The mesh has mapped the semantic and index <span class="NDLSystemFont">POSITION0</span> with the first 
 vertex element in the set, <span class="NDLSystemFont">NORMAL0</span> with 
 the second vertex element in the set, and <span class="NDLSystemFont">TEXCOORD0</span> 
 with the third vertex element in the set. Summing these elements 
 results in a size of 32 
 bytes per vertex in this stream, 
 meaning that a user must advance 32 bytes to reach the next vertex in 
 the array. The mesh has bound region 0 to sub-mesh 0 and region 1 to sub-mesh 1. </p>

<a name=Sub_meshSetupRules></a><h2>Sub-mesh Setup Rules</h2>

<p>There are a few rules to bear in mind when setting up 
 sub-meshes:</p>

<ul>
	
	<li>All <span class="NDLSystemFont">USAGE_VERTEX</span> 
 stream regions bound to the same sub-mesh must have the same number of 
 vertices. The only exception to this is <span class="NDLSystemFont">USAGE_VERTEX 
 </span>data streams that are instanced (<span class="NDLSystemFont">NiDataStreamRef::IsPerInstance</span> 
 returns true). This means that if a sub-mesh has 25 vertices, then all 
 data streams bound to that sub-mesh must also have exactly 25 vertices</li>
	
	<li><span class="NDLSystemFont">USAGE_VERTEX_INDEX</span> 
 data streams index values must be less than the range of the vertex regions 
 bound to the same sub-mesh. This means that if a sub-mesh has 25 vertices, 
 the index stream cannot have a value of 26 in it. This has interesting 
 ramifications for sub-meshes as it means that regions define the indexing 
 for vertex attributes. This is discussed in more detail <a href="NiMesh_Primer.htm#Indexed_and_non_indexed_geometry">below</a>. 
 </li>
	
	<li>Only one <span class="NDLSystemFont">USAGE_VERTEX_INDEX</span> 
 stream can be attached to a mesh.</li>
	
	<li>Every sub-mesh is required 
 to have a region binding for every stream attached to the mesh. Different 
 sub-meshes may point to the same region or they may point to a unique 
 region in a stream.</li>
</ul>

<a name=SharingAndRegions></a><h2>Sharing And Regions</h2>

<p>The sub-mesh bindings of an <span class="NDLSystemFont">NiDataStreamRef</span> 
 use the<span class="NDLSystemFont"> NiDataStream::Regions</span> as an indirection, 
 allowing multiple meshes to refer to the same data stream without having 
 to know the details of how the data stream has been broken into sections. 
 The following diagram illustrates the relationship between multiple meshes 
 that reference the same <span class="NDLSystemFont">NiDataStream</span>. 
 Note that the instancing parameters, semantic bindings, and <span class="NDLSystemFont">NiDataStreamElementSets</span> 
 have been left out for improved readability.</p>


<div class="NDLFigureContainer">
    <img src="./images/DataStreamRegionsMeshesAndRefs2.jpg" width="723" height="525" />
    <p class="NDLFigureCaption">Relationship between multiple meshes that reference the same NiDataStream</p>
</div>

<p>Note that it is possible for the two meshes to refer 
 to completely different regions of the same data stream. This flexibility 
 allows for many possibilities for data sharing, some examples are discussed 
 in <a href="Cloning_and_Data_Streams.htm">Cloning 
 and Data Streams</a>.</p>

<a name=Indexed_and_non_indexed_geometry></a><h2>Indexed and 
 non-indexed geometry</h2>

<p>Index streams use the same storage and access mechanism 
 as vertex data. They are allocated with the <span class="NDLSystemFont">NiDataStream::USAGE_VERTEX_INDEX</span> 
 usage flag and use a semantic dedicated for indexing (e.g. INDEX). Well-formed 
 indexed geometry will have one and only one stream that contains indices. 
 The stream that contains the indices should not contain other elements. 
 Since index streams refer to the vertices they reference by index, it 
 is important to note that by convention, vertex streams are indexed starting 
 from the beginning of the bound region. The image below illustrates this 
 relationship. I3 stores 0 as the index, which refers to V3, since V3 is 
 the 0-th item in the region bound to the same sub-mesh as the index stream.</p>


<div class="NDLFigureContainer">
    <img src="./images/SubmeshAndIndices.jpg" width="568" height="547" />
    <p class="NDLFigureCaption">Indexed and non-indexed geometry</p>
</div>

<p>Non-indexed geometry will not contain any indices. Multiple 
 index streams and indices interleaved with other elements are not supported. 
 Instead, multiple draws are supported via sub-meshes and regions, described 
 earlier. In that mechanism the index stream remains constant, but the 
 offset into the index steam may change between regions/draws. </p>

<a name=Use_Cases></a><h3>Use Cases</h3>

<h4>Use case: Basic </h4>

<p>The simplest use case is a static, indexed triangle 
 mesh. An example with 4 vertices and 2 triangles is illustrated below. 
 Each vertex has positions, normals, and UV coordinates interleaved. A 
 single region is defined for each stream.</p>


<div class="NDLFigureContainer">
    <img src="./images/UseCase0.jpg" width="597" height="705" />
    <p class="NDLFigureCaption">Static indexed triangle mesh</p>
</div>


<h4>Use case: Multiple Tri-Strips with no degenerate stitching</h4>

<p>The second use case is static indexed triangle stripped 
 mesh with two strips. Each vertex has positions, normals, and UV coordinates 
 interleaved. A single region is defined for the vertex data stream, and 
 two regions are used to represent the index stream for each strip. Note: 
 This pedagogical case is for reference only. On platforms that support 
 a primitive restart token, a single region could be used, and the strips 
 separated by a restart token. On platforms without restart token support, 
 degenerate triangles could be used. The case simply illustrates that the 
 multiple region mechanism allows for fast multiple draw calls. Vertex 
 streams do not need to be reset between sub-mesh draws; the region may 
 change but the streams and vertex elements remain constant. As an example, 
 new shader constants could be set between the sub-mesh draw operations 
 to provide different rendering behavior for each strip which would not 
 be possible with degenerates or a primitive restart index.</p>

<div class="NDLFigureContainer">
    <img src="./images/UseCase1.jpg" width="597" height="769" />
    <p class="NDLFigureCaption">Static indexed triangle stripped mesh with two strips</p>
</div>

<h4>Use case: Multiple skin partitions</h4>

<p>The third use case is a skinned indexed triangle mesh 
 with 2 sub-meshes. Each vertex has positions, normals, and UV coordinates 
 interleaved. Two regions are used on each stream, because the sub-meshes 
 are completely independent. This case is different from the previous one 
 for two reasons. One, the sub-meshes are completely independent; no stream 
 regions are shared between the sub-meshes. Two, the reason for breaking 
 up a skinned mesh is typically that the complete mesh would need to set 
 more shader constants (for bone matrices) than the hardware allows. The 
 mesh must therefore be partitioned into sub-meshes that do not exceed 
 the shader constant limit. The details of how <span class="NDLSystemFont">NiMesh</span> 
 will handle skinning will be defined later, but for now it should be pointed 
 out that bone matrix shader constants will need to be reset between sub-mesh 
 draw calls in this use case.</p>

<p>Note that this matches the scenario diagrammed in <a 
 href="NiMesh_Primer.htm#Indexed_and_non_indexed_geometry">Indexed and 
 non-indexed geometry</a>, so the index stream values must be relative 
 to the starting index of the regions the vertex streams use.</p>

<div class="NDLFigureContainer">
    <img src="./images/UseCase2.jpg" width="597" height="826" />
    <p class="NDLFigureCaption">Skinned indexed triangle mesh 
 with 2 sub-meshes</p>
</div>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

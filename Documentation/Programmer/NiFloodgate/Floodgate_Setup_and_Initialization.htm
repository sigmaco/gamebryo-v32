<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>Floodgate Setup and Initialization</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script> <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<h1>Floodgate Setup and Initialization</h1>

<p>This guide walks through the steps necessary to create 
 a simple application that uses <span class="NDLSystemFont">NiFloodgate</span>. 
 First, we define several buffers that will hold our sample data. For simplicity, 
 we will define our data buffers globally for this example.</p>

<p>In a real-world application these buffers, or streams 
 of data, could come from anywhere in the application and contain any kind 
 of data that requires processing. This might include geometry for transforming 
 and rendering, audio information for processing and playback, behavioral 
 data for AI analysis, complex skeletal data for elaborate character animation, 
 topological data for real-time terrain generation, video streams for decompression, 
 particle system and special effects data, and so on. </p>

<p>Finally, we create our main application class and specify 
 the objects that will operate on our data, or Kernels. Kernels are pieces 
 of code that define operations perform on one or more streams of data. 
 This will be explained in much more detail later in this guide.</p>

<h2>Source Code</h2>

<pre>
//---------------------------------------------------------------------------
// Includes
#include &lt;NiStreamProcessor.h&gt;
#include &lt;NiSPStream.h&gt;
#include &lt;NiSPTask.h&gt;
#include &lt;NiSPWorkflow.h&gt;
#include &lt;NiSPKernel.h&gt;
#include "ScaleKernel.h" // Explained in later section...
#include "Sum2Kernel.h" // Explained in later section...
//---------------------------------------------------------------------------
// Declare our sample buffers to hold 256 elements
NiUInt32 auiInputBuffer1[256];
NiUInt32 auiInputBuffer2[256];
NiUInt32 auiOutputBuffer1[256];
NiUInt32 auiOutputBuffer2[256];
NiUInt32 uiFixedInput = 10;
 
// MyApplication Class
class MyApplication : public NiSample
{
public:
    MyApplication();
    ~MyApplication();
...
protected:
...
    // Declare our Kernels - Explained in a later section
    Sum2Kernel  m_kSum2Kernel;
    ScaleKernel m_kScaleKernel;
...
};
 
//---------------------------------------------------------------------------
</pre>


<p>The next step is <a href="Floodgate_Specifying_Streams.htm">specifying 
 streams</a>.</p>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>

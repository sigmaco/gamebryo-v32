// EMERGENT GAME TECHNOLOGIES PROPRIETARY INFORMATION
//
// This software is supplied under the terms of a license agreement or
// nondisclosure agreement with Emergent Game Technologies and may not
// be copied or disclosed except in accordance with the terms of that
// agreement.
//
//      Copyright (c) 1996-2009 Emergent Game Technologies.
//      All Rights Reserved.
//
// Emergent Game Technologies, Calabasas, CA 91302
// http://www.emergent.net

#pragma once
#ifndef EE_IMESSAGEHELPERSYSTEMSERVICE_H
#define EE_IMESSAGEHELPERSYSTEMSERVICE_H

#include <efd/ISystemService.h>
#include <efd/NetMessage.h>
#include <efd/MessageService.h>

namespace efd
{

class ServiceManager;

/**
    This is sub-class of efd::ISystemService that provides some helpful common code for interacting
    with the efd::MessageService class.  This class implements public and private categories and
    automatically manages subscriptions to these categories.  These categories can then be used
    for message callbacks or general communication with the services in question.  In addition,
    when extending a program to work multi-process this service will automatically update the
    private categories to be unique across all processes with no additional handling.
*/
class EE_EFD_ENTRY IMessageHelperSystemService : public ISystemService
{
    /// @cond EMERGENT_INTERNAL
    EE_DECLARE_INTERFACE1(
        IMessageHelperSystemService,
        kCLASSID_IMessageHelperSystemService,
        ISystemService);
    /// @endcond

public:

    /**
        Constructor. Construct the IMessageHelperSystemService by passing in the class ID of the
        first derived class. This ID typically should not change if that class is further derived
        so that all instances of the first derived class will share a common public category even
        if they have different levels of final derivation.

        @param derivedID the efd::ClassID of the class that directly derives from this class.
        @param messageServiceClass The efd::ClassID of the MessageService to use.
    */
    IMessageHelperSystemService(
        efd::ClassID derivedID,
        efd::ClassID messageServiceClass = efd::MessageService::CLASS_ID);

    /**
        Get the private category. This category is unique to each instance of the class that
        derives from IMessageHelperSystemService even in cases where multiple processes are
        connected together.

        @note: the category returned by this method can change at run-time as the current process
            joins or disconnects from a channel manager. It is recommended that the returned value
            not be cached in case it changes.

        @return The private category unique to this service instance.
    */
    efd::Category GetPrivateCategory() const;

    /**
        Get the public category. This category is shared by all instances of the class that
        derives from IMessageHelperSystemService in all connected processes.
    */
    efd::Category GetPublicCategory() const;

    /**
        Handler for efd::AssignNetIDMessage messages.

        The categories generated by this class use the NetID to ensure they are globally unique.
        In multi-process applications this NetID can change at runtime when the process connects
        or disconnects to a channel manager. If the NetID changes we automatically unsubscribe
        from the old category and subscribe to the newly computed category.
    */
    void HandleAssignNetIDMessage(
        const efd::AssignNetIDMessage* pMessage,
        efd::Category targetChannel);

protected:
    /**
        Implementation of efd::ISystemService::OnPreInit that caches the MessageService and
        subscribes to the private and public categories.

        @note Derived classes that override OnPreInit need to call this implementation.

        @see efd::ISystemService::OnPreInit

        @return SyncResult_Success if the MessageService is cached and our subscriptions are
            configured, SyncResult_Failure otherwise.
    */
    virtual SyncResult OnPreInit(efd::IDependencyRegistrar* pDependencyRegistrar);

    /**
        Implementation of efd::ISystemService::OnPreInit that unsubscribes to the private and
        public categories for this service.

        @note Derived classes that override OnShutdown need to call this implementation. This
            method only needs to be called once during shutdown, so if your OnShutdown override
            can return AsyncResult_Pending it is recommended that you call this base class
            implementation as the last step of your own OnShutdown.

        @return This implementation always returns AsyncResult_Complete.
    */
    virtual AsyncResult OnShutdown();

    /// The ClassID of my final class.  This is provided rather than being computed from our
    /// IBase interface so that multiple inheritance chains can use the class ID of the first
    /// derived class rather than the final derived class.
    efd::ClassID m_classId;

    /// The ClassID of the MessageService. There may be multiple message services registered so we
    /// need to ensure we use the correct one. For example, when the RapidIterationService is in
    /// use it registers a separate MessageService for communication with AssetController/ToolBench.
    efd::ClassID m_messageServiceId;

    /// The NetID that was used when we subscribed. This ID can change in multi-process cases.
    efd::UInt32 m_netId;
};

/// A SmartPointer for the ISystemService class
typedef efd::SmartPointer<ISystemService> ISystemServicePtr;

} //  end namespace efd


#endif // EE_IMESSAGEHELPERSYSTEMSERVICE_H
